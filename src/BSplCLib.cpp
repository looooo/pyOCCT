/*
This file is part of pyOCCT which provides Python bindings to the OpenCASCADE
geometry kernel.

Copyright (C) 2016-2018  Laughlin Research, LLC (info@laughlinresearch.com)

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
*/
#include <pyOCCT_Common.hpp>

#include <BSplCLib_KnotDistribution.hxx>
#include <BSplCLib_MultDistribution.hxx>
#include <Standard_TypeDef.hxx>
#include <BSplCLib_EvaluatorFunction.hxx>
#include <TColStd_Array1OfReal.hxx>
#include <TColStd_Array1OfInteger.hxx>
#include <GeomAbs_BSplKnotDistribution.hxx>
#include <TColgp_Array1OfPnt.hxx>
#include <TColgp_Array1OfPnt2d.hxx>
#include <gp_Pnt.hxx>
#include <gp_Pnt2d.hxx>
#include <gp_Vec.hxx>
#include <gp_Vec2d.hxx>
#include <math_Matrix.hxx>
#include <Standard_Handle.hxx>
#include <TColStd_HArray1OfReal.hxx>
#include <TColStd_HArray1OfInteger.hxx>
#include <TColStd_Array2OfReal.hxx>
#include <BSplCLib.hxx>
#include <Standard_Transient.hxx>
#include <Standard_Type.hxx>
#include <BSplCLib_Cache.hxx>

PYBIND11_MODULE(BSplCLib, mod) {

	// IMPORT
	py::module::import("OCCT.Standard");
	py::module::import("OCCT.TColStd");
	py::module::import("OCCT.GeomAbs");
	py::module::import("OCCT.TColgp");
	py::module::import("OCCT.gp");
	py::module::import("OCCT.math");

	py::module other_mod;

	// IMPORT GUARDS

	// ENUMS
	// C:\Miniconda\envs\occt\Library\include\opencascade\BSplCLib_KnotDistribution.hxx
	py::enum_<BSplCLib_KnotDistribution>(mod, "BSplCLib_KnotDistribution", "This enumeration describes the repartition of the knots sequence. If all the knots differ by the same positive constant from the preceding knot the 'KnotDistribution' is <Uniform> else it is <NonUniform>")
		.value("BSplCLib_NonUniform", BSplCLib_KnotDistribution::BSplCLib_NonUniform)
		.value("BSplCLib_Uniform", BSplCLib_KnotDistribution::BSplCLib_Uniform)
		.export_values();
	// C:\Miniconda\envs\occt\Library\include\opencascade\BSplCLib_MultDistribution.hxx
	py::enum_<BSplCLib_MultDistribution>(mod, "BSplCLib_MultDistribution", "This enumeration describes the form of the sequence of mutiplicities. MultDistribution is :")
		.value("BSplCLib_NonConstant", BSplCLib_MultDistribution::BSplCLib_NonConstant)
		.value("BSplCLib_Constant", BSplCLib_MultDistribution::BSplCLib_Constant)
		.value("BSplCLib_QuasiConstant", BSplCLib_MultDistribution::BSplCLib_QuasiConstant)
		.export_values();

	// FUNCTIONS

	// CLASSES
	// Callback for BSplCLib_EvaluatorFunction.
	class PyCallback_BSplCLib_EvaluatorFunction : public BSplCLib_EvaluatorFunction {
	public:
		using BSplCLib_EvaluatorFunction::BSplCLib_EvaluatorFunction;

		void Evaluate(const Standard_Integer theDerivativeRequest, const Standard_Real * theStartEnd, const Standard_Real theParameter, Standard_Real & theResult, Standard_Integer & theErrorCode) const  override { PYBIND11_OVERLOAD_PURE(void, BSplCLib_EvaluatorFunction, Evaluate, theDerivativeRequest, theStartEnd, theParameter, theResult, theErrorCode); }
	};

	// C:\Miniconda\envs\occt\Library\include\opencascade\BSplCLib_EvaluatorFunction.hxx
	py::class_<BSplCLib_EvaluatorFunction, std::unique_ptr<BSplCLib_EvaluatorFunction, Deleter<BSplCLib_EvaluatorFunction>>, PyCallback_BSplCLib_EvaluatorFunction> cls_BSplCLib_EvaluatorFunction(mod, "BSplCLib_EvaluatorFunction", "None");
	cls_BSplCLib_EvaluatorFunction.def(py::init<>());
	cls_BSplCLib_EvaluatorFunction.def("Evaluate", [](BSplCLib_EvaluatorFunction &self, const Standard_Integer theDerivativeRequest, const Standard_Real * theStartEnd, const Standard_Real theParameter, Standard_Real & theResult, Standard_Integer & theErrorCode){ self.Evaluate(theDerivativeRequest, theStartEnd, theParameter, theResult, theErrorCode); return std::tuple<Standard_Real &, Standard_Integer &>(theResult, theErrorCode); }, "Function evaluation method to be defined by descendant", py::arg("theDerivativeRequest"), py::arg("theStartEnd"), py::arg("theParameter"), py::arg("theResult"), py::arg("theErrorCode"));
	cls_BSplCLib_EvaluatorFunction.def("__call__", (void (BSplCLib_EvaluatorFunction::*)(const Standard_Integer, const Standard_Real *, const Standard_Real, Standard_Real &, Standard_Integer &) const ) &BSplCLib_EvaluatorFunction::operator(), py::is_operator(), "Shortcut for function-call style usage", py::arg("theDerivativeRequest"), py::arg("theStartEnd"), py::arg("theParameter"), py::arg("theResult"), py::arg("theErrorCode"));

	// C:\Miniconda\envs\occt\Library\include\opencascade\BSplCLib.hxx
	py::class_<BSplCLib, std::unique_ptr<BSplCLib, Deleter<BSplCLib>>> cls_BSplCLib(mod, "BSplCLib", "BSplCLib B-spline curve Library.");
	cls_BSplCLib.def(py::init<>());
	cls_BSplCLib.def_static("Hunt_", [](const TColStd_Array1OfReal & XX, const Standard_Real X, Standard_Integer & Iloc){ BSplCLib::Hunt(XX, X, Iloc); return Iloc; }, "This routine searches the position of the real value X in the ordered set of real values XX.", py::arg("XX"), py::arg("X"), py::arg("Iloc"));
	cls_BSplCLib.def_static("FirstUKnotIndex_", (Standard_Integer (*)(const Standard_Integer, const TColStd_Array1OfInteger &)) &BSplCLib::FirstUKnotIndex, "Computes the index of the knots value which gives the start point of the curve.", py::arg("Degree"), py::arg("Mults"));
	cls_BSplCLib.def_static("LastUKnotIndex_", (Standard_Integer (*)(const Standard_Integer, const TColStd_Array1OfInteger &)) &BSplCLib::LastUKnotIndex, "Computes the index of the knots value which gives the end point of the curve.", py::arg("Degree"), py::arg("Mults"));
	cls_BSplCLib.def_static("FlatIndex_", (Standard_Integer (*)(const Standard_Integer, const Standard_Integer, const TColStd_Array1OfInteger &, const Standard_Boolean)) &BSplCLib::FlatIndex, "Computes the index of the flats knots sequence corresponding to <Index> in the knots sequence which multiplicities are <Mults>.", py::arg("Degree"), py::arg("Index"), py::arg("Mults"), py::arg("Periodic"));
	cls_BSplCLib.def_static("LocateParameter_", [](const Standard_Integer Degree, const TColStd_Array1OfReal & Knots, const TColStd_Array1OfInteger & Mults, const Standard_Real U, const Standard_Boolean IsPeriodic, const Standard_Integer FromK1, const Standard_Integer ToK2, Standard_Integer & KnotIndex, Standard_Real & NewU){ BSplCLib::LocateParameter(Degree, Knots, Mults, U, IsPeriodic, FromK1, ToK2, KnotIndex, NewU); return std::tuple<Standard_Integer &, Standard_Real &>(KnotIndex, NewU); }, "Locates the parametric value U in the knots sequence between the knot K1 and the knot K2. The value return in Index verifies.", py::arg("Degree"), py::arg("Knots"), py::arg("Mults"), py::arg("U"), py::arg("IsPeriodic"), py::arg("FromK1"), py::arg("ToK2"), py::arg("KnotIndex"), py::arg("NewU"));
	cls_BSplCLib.def_static("LocateParameter_", [](const Standard_Integer Degree, const TColStd_Array1OfReal & Knots, const Standard_Real U, const Standard_Boolean IsPeriodic, const Standard_Integer FromK1, const Standard_Integer ToK2, Standard_Integer & KnotIndex, Standard_Real & NewU){ BSplCLib::LocateParameter(Degree, Knots, U, IsPeriodic, FromK1, ToK2, KnotIndex, NewU); return std::tuple<Standard_Integer &, Standard_Real &>(KnotIndex, NewU); }, "Locates the parametric value U in the knots sequence between the knot K1 and the knot K2. The value return in Index verifies.", py::arg("Degree"), py::arg("Knots"), py::arg("U"), py::arg("IsPeriodic"), py::arg("FromK1"), py::arg("ToK2"), py::arg("KnotIndex"), py::arg("NewU"));
	cls_BSplCLib.def_static("LocateParameter_", [](const Standard_Integer Degree, const TColStd_Array1OfReal & Knots, const TColStd_Array1OfInteger * Mults, const Standard_Real U, const Standard_Boolean Periodic, Standard_Integer & Index, Standard_Real & NewU){ BSplCLib::LocateParameter(Degree, Knots, Mults, U, Periodic, Index, NewU); return std::tuple<Standard_Integer &, Standard_Real &>(Index, NewU); }, "None", py::arg("Degree"), py::arg("Knots"), py::arg("Mults"), py::arg("U"), py::arg("Periodic"), py::arg("Index"), py::arg("NewU"));
	cls_BSplCLib.def_static("MaxKnotMult_", (Standard_Integer (*)(const TColStd_Array1OfInteger &, const Standard_Integer, const Standard_Integer)) &BSplCLib::MaxKnotMult, "Finds the greatest multiplicity in a set of knots between K1 and K2. Mults is the multiplicity associated with each knot value.", py::arg("Mults"), py::arg("K1"), py::arg("K2"));
	cls_BSplCLib.def_static("MinKnotMult_", (Standard_Integer (*)(const TColStd_Array1OfInteger &, const Standard_Integer, const Standard_Integer)) &BSplCLib::MinKnotMult, "Finds the lowest multiplicity in a set of knots between K1 and K2. Mults is the multiplicity associated with each knot value.", py::arg("Mults"), py::arg("K1"), py::arg("K2"));
	cls_BSplCLib.def_static("NbPoles_", (Standard_Integer (*)(const Standard_Integer, const Standard_Boolean, const TColStd_Array1OfInteger &)) &BSplCLib::NbPoles, "Returns the number of poles of the curve. Returns 0 if one of the multiplicities is incorrect.", py::arg("Degree"), py::arg("Periodic"), py::arg("Mults"));
	cls_BSplCLib.def_static("KnotSequenceLength_", (Standard_Integer (*)(const TColStd_Array1OfInteger &, const Standard_Integer, const Standard_Boolean)) &BSplCLib::KnotSequenceLength, "Returns the length of the sequence of knots with repetition.", py::arg("Mults"), py::arg("Degree"), py::arg("Periodic"));
	cls_BSplCLib.def_static("KnotSequence_", [](const TColStd_Array1OfReal & a0, const TColStd_Array1OfInteger & a1, TColStd_Array1OfReal & a2) -> void { return BSplCLib::KnotSequence(a0, a1, a2); }, py::arg("Knots"), py::arg("Mults"), py::arg("KnotSeq"));
	cls_BSplCLib.def_static("KnotSequence_", (void (*)(const TColStd_Array1OfReal &, const TColStd_Array1OfInteger &, TColStd_Array1OfReal &, const Standard_Boolean)) &BSplCLib::KnotSequence, "None", py::arg("Knots"), py::arg("Mults"), py::arg("KnotSeq"), py::arg("Periodic"));
	cls_BSplCLib.def_static("KnotSequence_", (void (*)(const TColStd_Array1OfReal &, const TColStd_Array1OfInteger &, const Standard_Integer, const Standard_Boolean, TColStd_Array1OfReal &)) &BSplCLib::KnotSequence, "Computes the sequence of knots KnotSeq with repetition of the knots of multiplicity greater than 1.", py::arg("Knots"), py::arg("Mults"), py::arg("Degree"), py::arg("Periodic"), py::arg("KnotSeq"));
	cls_BSplCLib.def_static("KnotsLength_", [](const TColStd_Array1OfReal & a0) -> Standard_Integer { return BSplCLib::KnotsLength(a0); }, py::arg("KnotSeq"));
	cls_BSplCLib.def_static("KnotsLength_", (Standard_Integer (*)(const TColStd_Array1OfReal &, const Standard_Boolean)) &BSplCLib::KnotsLength, "Returns the length of the sequence of knots (and Mults) without repetition.", py::arg("KnotSeq"), py::arg("Periodic"));
	cls_BSplCLib.def_static("Knots_", [](const TColStd_Array1OfReal & a0, TColStd_Array1OfReal & a1, TColStd_Array1OfInteger & a2) -> void { return BSplCLib::Knots(a0, a1, a2); }, py::arg("KnotSeq"), py::arg("Knots"), py::arg("Mults"));
	cls_BSplCLib.def_static("Knots_", (void (*)(const TColStd_Array1OfReal &, TColStd_Array1OfReal &, TColStd_Array1OfInteger &, const Standard_Boolean)) &BSplCLib::Knots, "Computes the sequence of knots Knots without repetition of the knots of multiplicity greater than 1.", py::arg("KnotSeq"), py::arg("Knots"), py::arg("Mults"), py::arg("Periodic"));
	cls_BSplCLib.def_static("KnotForm_", (BSplCLib_KnotDistribution (*)(const TColStd_Array1OfReal &, const Standard_Integer, const Standard_Integer)) &BSplCLib::KnotForm, "Analyses if the knots distribution is 'Uniform' or 'NonUniform' between the knot FromK1 and the knot ToK2. There is no repetition of knot in the knots'sequence <Knots>.", py::arg("Knots"), py::arg("FromK1"), py::arg("ToK2"));
	cls_BSplCLib.def_static("MultForm_", (BSplCLib_MultDistribution (*)(const TColStd_Array1OfInteger &, const Standard_Integer, const Standard_Integer)) &BSplCLib::MultForm, "Analyses the distribution of multiplicities between the knot FromK1 and the Knot ToK2.", py::arg("Mults"), py::arg("FromK1"), py::arg("ToK2"));
	cls_BSplCLib.def_static("KnotAnalysis_", [](const Standard_Integer Degree, const Standard_Boolean Periodic, const TColStd_Array1OfReal & CKnots, const TColStd_Array1OfInteger & CMults, GeomAbs_BSplKnotDistribution & KnotForm, Standard_Integer & MaxKnotMult){ BSplCLib::KnotAnalysis(Degree, Periodic, CKnots, CMults, KnotForm, MaxKnotMult); return MaxKnotMult; }, "Analyzes the array of knots. Returns the form and the maximum knot multiplicity.", py::arg("Degree"), py::arg("Periodic"), py::arg("CKnots"), py::arg("CMults"), py::arg("KnotForm"), py::arg("MaxKnotMult"));
	cls_BSplCLib.def_static("Reparametrize_", (void (*)(const Standard_Real, const Standard_Real, TColStd_Array1OfReal &)) &BSplCLib::Reparametrize, "Reparametrizes a B-spline curve to [U1, U2]. The knot values are recomputed such that Knots (Lower) = U1 and Knots (Upper) = U2 but the knot form is not modified. Warnings : In the array Knots the values must be in ascending order. U1 must not be equal to U2 to avoid division by zero.", py::arg("U1"), py::arg("U2"), py::arg("Knots"));
	cls_BSplCLib.def_static("Reverse_", (void (*)(TColStd_Array1OfReal &)) &BSplCLib::Reverse, "Reverses the array knots to become the knots sequence of the reversed curve.", py::arg("Knots"));
	cls_BSplCLib.def_static("Reverse_", (void (*)(TColStd_Array1OfInteger &)) &BSplCLib::Reverse, "Reverses the array of multiplicities.", py::arg("Mults"));
	cls_BSplCLib.def_static("Reverse_", (void (*)(TColgp_Array1OfPnt &, const Standard_Integer)) &BSplCLib::Reverse, "Reverses the array of poles. Last is the index of the new first pole. On a non periodic curve last is Poles.Upper(). On a periodic curve last is", py::arg("Poles"), py::arg("Last"));
	cls_BSplCLib.def_static("Reverse_", (void (*)(TColgp_Array1OfPnt2d &, const Standard_Integer)) &BSplCLib::Reverse, "Reverses the array of poles.", py::arg("Poles"), py::arg("Last"));
	cls_BSplCLib.def_static("Reverse_", (void (*)(TColStd_Array1OfReal &, const Standard_Integer)) &BSplCLib::Reverse, "Reverses the array of poles.", py::arg("Weights"), py::arg("Last"));
	cls_BSplCLib.def_static("IsRational_", [](const TColStd_Array1OfReal & a0, const Standard_Integer a1, const Standard_Integer a2) -> Standard_Boolean { return BSplCLib::IsRational(a0, a1, a2); }, py::arg("Weights"), py::arg("I1"), py::arg("I2"));
	cls_BSplCLib.def_static("IsRational_", (Standard_Boolean (*)(const TColStd_Array1OfReal &, const Standard_Integer, const Standard_Integer, const Standard_Real)) &BSplCLib::IsRational, "Returns False if all the weights of the array <Weights> between I1 an I2 are identic. Epsilon is used for comparing weights. If Epsilon is 0. the Epsilon of the first weight is used.", py::arg("Weights"), py::arg("I1"), py::arg("I2"), py::arg("Epsilon"));
	cls_BSplCLib.def_static("MaxDegree_", (Standard_Integer (*)()) &BSplCLib::MaxDegree, "returns the degree maxima for a BSplineCurve.");
	cls_BSplCLib.def_static("Eval_", [](const Standard_Real U, const Standard_Integer Degree, Standard_Real & Knots, const Standard_Integer Dimension, Standard_Real & Poles){ BSplCLib::Eval(U, Degree, Knots, Dimension, Poles); return std::tuple<Standard_Real &, Standard_Real &>(Knots, Poles); }, "Perform the Boor algorithm to evaluate a point at parameter <U>, with <Degree> and <Dimension>.", py::arg("U"), py::arg("Degree"), py::arg("Knots"), py::arg("Dimension"), py::arg("Poles"));
	cls_BSplCLib.def_static("BoorScheme_", [](const Standard_Real U, const Standard_Integer Degree, Standard_Real & Knots, const Standard_Integer Dimension, Standard_Real & Poles, const Standard_Integer Depth, const Standard_Integer Length){ BSplCLib::BoorScheme(U, Degree, Knots, Dimension, Poles, Depth, Length); return std::tuple<Standard_Real &, Standard_Real &>(Knots, Poles); }, "Performs the Boor Algorithm at parameter <U> with the given <Degree> and the array of <Knots> on the poles <Poles> of dimension <Dimension>. The schema is computed until level <Depth> on a basis of <Length+1> poles.", py::arg("U"), py::arg("Degree"), py::arg("Knots"), py::arg("Dimension"), py::arg("Poles"), py::arg("Depth"), py::arg("Length"));
	cls_BSplCLib.def_static("AntiBoorScheme_", [](const Standard_Real U, const Standard_Integer Degree, Standard_Real & Knots, const Standard_Integer Dimension, Standard_Real & Poles, const Standard_Integer Depth, const Standard_Integer Length, const Standard_Real Tolerance){ Standard_Boolean rv = BSplCLib::AntiBoorScheme(U, Degree, Knots, Dimension, Poles, Depth, Length, Tolerance); return std::tuple<Standard_Boolean, Standard_Real &, Standard_Real &>(rv, Knots, Poles); }, "Compute the content of Pole before the BoorScheme. This method is used to remove poles.", py::arg("U"), py::arg("Degree"), py::arg("Knots"), py::arg("Dimension"), py::arg("Poles"), py::arg("Depth"), py::arg("Length"), py::arg("Tolerance"));
	cls_BSplCLib.def_static("Derivative_", [](const Standard_Integer Degree, Standard_Real & Knots, const Standard_Integer Dimension, const Standard_Integer Length, const Standard_Integer Order, Standard_Real & Poles){ BSplCLib::Derivative(Degree, Knots, Dimension, Length, Order, Poles); return std::tuple<Standard_Real &, Standard_Real &>(Knots, Poles); }, "Computes the poles of the BSpline giving the derivatives of order <Order>.", py::arg("Degree"), py::arg("Knots"), py::arg("Dimension"), py::arg("Length"), py::arg("Order"), py::arg("Poles"));
	cls_BSplCLib.def_static("Bohm_", [](const Standard_Real U, const Standard_Integer Degree, const Standard_Integer N, Standard_Real & Knots, const Standard_Integer Dimension, Standard_Real & Poles){ BSplCLib::Bohm(U, Degree, N, Knots, Dimension, Poles); return std::tuple<Standard_Real &, Standard_Real &>(Knots, Poles); }, "Performs the Bohm Algorithm at parameter <U>. This algorithm computes the value and all the derivatives up to order N (N <= Degree).", py::arg("U"), py::arg("Degree"), py::arg("N"), py::arg("Knots"), py::arg("Dimension"), py::arg("Poles"));
	cls_BSplCLib.def_static("NoWeights_", (TColStd_Array1OfReal * (*)()) &BSplCLib::NoWeights, "Used as argument for a non rational curve.");
	cls_BSplCLib.def_static("NoMults_", (TColStd_Array1OfInteger * (*)()) &BSplCLib::NoMults, "Used as argument for a flatknots evaluation.");
	cls_BSplCLib.def_static("BuildKnots_", [](const Standard_Integer Degree, const Standard_Integer Index, const Standard_Boolean Periodic, const TColStd_Array1OfReal & Knots, const TColStd_Array1OfInteger * Mults, Standard_Real & LK){ BSplCLib::BuildKnots(Degree, Index, Periodic, Knots, Mults, LK); return LK; }, "Stores in LK the usefull knots for the BoorSchem on the span Knots(Index) - Knots(Index+1)", py::arg("Degree"), py::arg("Index"), py::arg("Periodic"), py::arg("Knots"), py::arg("Mults"), py::arg("LK"));
	cls_BSplCLib.def_static("PoleIndex_", (Standard_Integer (*)(const Standard_Integer, const Standard_Integer, const Standard_Boolean, const TColStd_Array1OfInteger &)) &BSplCLib::PoleIndex, "Return the index of the first Pole to use on the span Mults(Index) - Mults(Index+1). This index must be added to Poles.Lower().", py::arg("Degree"), py::arg("Index"), py::arg("Periodic"), py::arg("Mults"));
	cls_BSplCLib.def_static("BuildEval_", [](const Standard_Integer Degree, const Standard_Integer Index, const TColStd_Array1OfReal & Poles, const TColStd_Array1OfReal * Weights, Standard_Real & LP){ BSplCLib::BuildEval(Degree, Index, Poles, Weights, LP); return LP; }, "None", py::arg("Degree"), py::arg("Index"), py::arg("Poles"), py::arg("Weights"), py::arg("LP"));
	cls_BSplCLib.def_static("BuildEval_", [](const Standard_Integer Degree, const Standard_Integer Index, const TColgp_Array1OfPnt & Poles, const TColStd_Array1OfReal * Weights, Standard_Real & LP){ BSplCLib::BuildEval(Degree, Index, Poles, Weights, LP); return LP; }, "None", py::arg("Degree"), py::arg("Index"), py::arg("Poles"), py::arg("Weights"), py::arg("LP"));
	cls_BSplCLib.def_static("BuildEval_", [](const Standard_Integer Degree, const Standard_Integer Index, const TColgp_Array1OfPnt2d & Poles, const TColStd_Array1OfReal * Weights, Standard_Real & LP){ BSplCLib::BuildEval(Degree, Index, Poles, Weights, LP); return LP; }, "Copy in <LP> the poles and weights for the Eval scheme. starting from Poles(Poles.Lower()+Index)", py::arg("Degree"), py::arg("Index"), py::arg("Poles"), py::arg("Weights"), py::arg("LP"));
	cls_BSplCLib.def_static("BuildBoor_", [](const Standard_Integer Index, const Standard_Integer Length, const Standard_Integer Dimension, const TColStd_Array1OfReal & Poles, Standard_Real & LP){ BSplCLib::BuildBoor(Index, Length, Dimension, Poles, LP); return LP; }, "Copy in <LP> poles for <Dimension> Boor scheme. Starting from <Index> * <Dimension>, copy <Length+1> poles.", py::arg("Index"), py::arg("Length"), py::arg("Dimension"), py::arg("Poles"), py::arg("LP"));
	cls_BSplCLib.def_static("BoorIndex_", (Standard_Integer (*)(const Standard_Integer, const Standard_Integer, const Standard_Integer)) &BSplCLib::BoorIndex, "Returns the index in the Boor result array of the poles <Index>. If the Boor algorithm was perform with <Length> and <Depth>.", py::arg("Index"), py::arg("Length"), py::arg("Depth"));
	cls_BSplCLib.def_static("GetPole_", [](const Standard_Integer Index, const Standard_Integer Length, const Standard_Integer Depth, const Standard_Integer Dimension, Standard_Real & LocPoles, Standard_Integer & Position, TColStd_Array1OfReal & Pole){ BSplCLib::GetPole(Index, Length, Depth, Dimension, LocPoles, Position, Pole); return std::tuple<Standard_Real &, Standard_Integer &>(LocPoles, Position); }, "Copy the pole at position <Index> in the Boor scheme of dimension <Dimension> to <Position> in the array <Pole>. <Position> is updated.", py::arg("Index"), py::arg("Length"), py::arg("Depth"), py::arg("Dimension"), py::arg("LocPoles"), py::arg("Position"), py::arg("Pole"));
	cls_BSplCLib.def_static("PrepareInsertKnots_", [](const Standard_Integer Degree, const Standard_Boolean Periodic, const TColStd_Array1OfReal & Knots, const TColStd_Array1OfInteger & Mults, const TColStd_Array1OfReal & AddKnots, const TColStd_Array1OfInteger * AddMults, Standard_Integer & NbPoles, Standard_Integer & NbKnots, const Standard_Real Epsilon, const Standard_Boolean Add){ Standard_Boolean rv = BSplCLib::PrepareInsertKnots(Degree, Periodic, Knots, Mults, AddKnots, AddMults, NbPoles, NbKnots, Epsilon, Add); return std::tuple<Standard_Boolean, Standard_Integer &, Standard_Integer &>(rv, NbPoles, NbKnots); }, "Returns in <NbPoles, NbKnots> the new number of poles and knots if the sequence of knots <AddKnots, AddMults> is inserted in the sequence <Knots, Mults>.", py::arg("Degree"), py::arg("Periodic"), py::arg("Knots"), py::arg("Mults"), py::arg("AddKnots"), py::arg("AddMults"), py::arg("NbPoles"), py::arg("NbKnots"), py::arg("Epsilon"), py::arg("Add"));
	cls_BSplCLib.def_static("InsertKnots_", [](const Standard_Integer a0, const Standard_Boolean a1, const Standard_Integer a2, const TColStd_Array1OfReal & a3, const TColStd_Array1OfReal & a4, const TColStd_Array1OfInteger & a5, const TColStd_Array1OfReal & a6, const TColStd_Array1OfInteger * a7, TColStd_Array1OfReal & a8, TColStd_Array1OfReal & a9, TColStd_Array1OfInteger & a10, const Standard_Real a11) -> void { return BSplCLib::InsertKnots(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11); }, py::arg("Degree"), py::arg("Periodic"), py::arg("Dimension"), py::arg("Poles"), py::arg("Knots"), py::arg("Mults"), py::arg("AddKnots"), py::arg("AddMults"), py::arg("NewPoles"), py::arg("NewKnots"), py::arg("NewMults"), py::arg("Epsilon"));
	cls_BSplCLib.def_static("InsertKnots_", (void (*)(const Standard_Integer, const Standard_Boolean, const Standard_Integer, const TColStd_Array1OfReal &, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger &, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger *, TColStd_Array1OfReal &, TColStd_Array1OfReal &, TColStd_Array1OfInteger &, const Standard_Real, const Standard_Boolean)) &BSplCLib::InsertKnots, "None", py::arg("Degree"), py::arg("Periodic"), py::arg("Dimension"), py::arg("Poles"), py::arg("Knots"), py::arg("Mults"), py::arg("AddKnots"), py::arg("AddMults"), py::arg("NewPoles"), py::arg("NewKnots"), py::arg("NewMults"), py::arg("Epsilon"), py::arg("Add"));
	cls_BSplCLib.def_static("InsertKnots_", [](const Standard_Integer a0, const Standard_Boolean a1, const TColgp_Array1OfPnt & a2, const TColStd_Array1OfReal * a3, const TColStd_Array1OfReal & a4, const TColStd_Array1OfInteger & a5, const TColStd_Array1OfReal & a6, const TColStd_Array1OfInteger * a7, TColgp_Array1OfPnt & a8, TColStd_Array1OfReal * a9, TColStd_Array1OfReal & a10, TColStd_Array1OfInteger & a11, const Standard_Real a12) -> void { return BSplCLib::InsertKnots(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12); }, py::arg("Degree"), py::arg("Periodic"), py::arg("Poles"), py::arg("Weights"), py::arg("Knots"), py::arg("Mults"), py::arg("AddKnots"), py::arg("AddMults"), py::arg("NewPoles"), py::arg("NewWeights"), py::arg("NewKnots"), py::arg("NewMults"), py::arg("Epsilon"));
	cls_BSplCLib.def_static("InsertKnots_", (void (*)(const Standard_Integer, const Standard_Boolean, const TColgp_Array1OfPnt &, const TColStd_Array1OfReal *, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger &, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger *, TColgp_Array1OfPnt &, TColStd_Array1OfReal *, TColStd_Array1OfReal &, TColStd_Array1OfInteger &, const Standard_Real, const Standard_Boolean)) &BSplCLib::InsertKnots, "None", py::arg("Degree"), py::arg("Periodic"), py::arg("Poles"), py::arg("Weights"), py::arg("Knots"), py::arg("Mults"), py::arg("AddKnots"), py::arg("AddMults"), py::arg("NewPoles"), py::arg("NewWeights"), py::arg("NewKnots"), py::arg("NewMults"), py::arg("Epsilon"), py::arg("Add"));
	cls_BSplCLib.def_static("InsertKnots_", [](const Standard_Integer a0, const Standard_Boolean a1, const TColgp_Array1OfPnt2d & a2, const TColStd_Array1OfReal * a3, const TColStd_Array1OfReal & a4, const TColStd_Array1OfInteger & a5, const TColStd_Array1OfReal & a6, const TColStd_Array1OfInteger * a7, TColgp_Array1OfPnt2d & a8, TColStd_Array1OfReal * a9, TColStd_Array1OfReal & a10, TColStd_Array1OfInteger & a11, const Standard_Real a12) -> void { return BSplCLib::InsertKnots(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12); }, py::arg("Degree"), py::arg("Periodic"), py::arg("Poles"), py::arg("Weights"), py::arg("Knots"), py::arg("Mults"), py::arg("AddKnots"), py::arg("AddMults"), py::arg("NewPoles"), py::arg("NewWeights"), py::arg("NewKnots"), py::arg("NewMults"), py::arg("Epsilon"));
	cls_BSplCLib.def_static("InsertKnots_", (void (*)(const Standard_Integer, const Standard_Boolean, const TColgp_Array1OfPnt2d &, const TColStd_Array1OfReal *, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger &, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger *, TColgp_Array1OfPnt2d &, TColStd_Array1OfReal *, TColStd_Array1OfReal &, TColStd_Array1OfInteger &, const Standard_Real, const Standard_Boolean)) &BSplCLib::InsertKnots, "Insert a sequence of knots <AddKnots> with multiplicities <AddMults>. <AddKnots> must be a non decreasing sequence and verifies :", py::arg("Degree"), py::arg("Periodic"), py::arg("Poles"), py::arg("Weights"), py::arg("Knots"), py::arg("Mults"), py::arg("AddKnots"), py::arg("AddMults"), py::arg("NewPoles"), py::arg("NewWeights"), py::arg("NewKnots"), py::arg("NewMults"), py::arg("Epsilon"), py::arg("Add"));
	cls_BSplCLib.def_static("InsertKnot_", (void (*)(const Standard_Integer, const Standard_Real, const Standard_Integer, const Standard_Integer, const Standard_Boolean, const TColgp_Array1OfPnt &, const TColStd_Array1OfReal *, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger &, TColgp_Array1OfPnt &, TColStd_Array1OfReal *)) &BSplCLib::InsertKnot, "None", py::arg("UIndex"), py::arg("U"), py::arg("UMult"), py::arg("Degree"), py::arg("Periodic"), py::arg("Poles"), py::arg("Weights"), py::arg("Knots"), py::arg("Mults"), py::arg("NewPoles"), py::arg("NewWeights"));
	cls_BSplCLib.def_static("InsertKnot_", (void (*)(const Standard_Integer, const Standard_Real, const Standard_Integer, const Standard_Integer, const Standard_Boolean, const TColgp_Array1OfPnt2d &, const TColStd_Array1OfReal *, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger &, TColgp_Array1OfPnt2d &, TColStd_Array1OfReal *)) &BSplCLib::InsertKnot, "Insert a new knot U of multiplicity UMult in the knot sequence.", py::arg("UIndex"), py::arg("U"), py::arg("UMult"), py::arg("Degree"), py::arg("Periodic"), py::arg("Poles"), py::arg("Weights"), py::arg("Knots"), py::arg("Mults"), py::arg("NewPoles"), py::arg("NewWeights"));
	cls_BSplCLib.def_static("RaiseMultiplicity_", (void (*)(const Standard_Integer, const Standard_Integer, const Standard_Integer, const Standard_Boolean, const TColgp_Array1OfPnt &, const TColStd_Array1OfReal *, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger &, TColgp_Array1OfPnt &, TColStd_Array1OfReal *)) &BSplCLib::RaiseMultiplicity, "None", py::arg("KnotIndex"), py::arg("Mult"), py::arg("Degree"), py::arg("Periodic"), py::arg("Poles"), py::arg("Weights"), py::arg("Knots"), py::arg("Mults"), py::arg("NewPoles"), py::arg("NewWeights"));
	cls_BSplCLib.def_static("RaiseMultiplicity_", (void (*)(const Standard_Integer, const Standard_Integer, const Standard_Integer, const Standard_Boolean, const TColgp_Array1OfPnt2d &, const TColStd_Array1OfReal *, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger &, TColgp_Array1OfPnt2d &, TColStd_Array1OfReal *)) &BSplCLib::RaiseMultiplicity, "Raise the multiplicity of knot to <UMult>.", py::arg("KnotIndex"), py::arg("Mult"), py::arg("Degree"), py::arg("Periodic"), py::arg("Poles"), py::arg("Weights"), py::arg("Knots"), py::arg("Mults"), py::arg("NewPoles"), py::arg("NewWeights"));
	cls_BSplCLib.def_static("RemoveKnot_", (Standard_Boolean (*)(const Standard_Integer, const Standard_Integer, const Standard_Integer, const Standard_Boolean, const Standard_Integer, const TColStd_Array1OfReal &, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger &, TColStd_Array1OfReal &, TColStd_Array1OfReal &, TColStd_Array1OfInteger &, const Standard_Real)) &BSplCLib::RemoveKnot, "None", py::arg("Index"), py::arg("Mult"), py::arg("Degree"), py::arg("Periodic"), py::arg("Dimension"), py::arg("Poles"), py::arg("Knots"), py::arg("Mults"), py::arg("NewPoles"), py::arg("NewKnots"), py::arg("NewMults"), py::arg("Tolerance"));
	cls_BSplCLib.def_static("RemoveKnot_", (Standard_Boolean (*)(const Standard_Integer, const Standard_Integer, const Standard_Integer, const Standard_Boolean, const TColgp_Array1OfPnt &, const TColStd_Array1OfReal *, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger &, TColgp_Array1OfPnt &, TColStd_Array1OfReal *, TColStd_Array1OfReal &, TColStd_Array1OfInteger &, const Standard_Real)) &BSplCLib::RemoveKnot, "None", py::arg("Index"), py::arg("Mult"), py::arg("Degree"), py::arg("Periodic"), py::arg("Poles"), py::arg("Weights"), py::arg("Knots"), py::arg("Mults"), py::arg("NewPoles"), py::arg("NewWeights"), py::arg("NewKnots"), py::arg("NewMults"), py::arg("Tolerance"));
	cls_BSplCLib.def_static("RemoveKnot_", (Standard_Boolean (*)(const Standard_Integer, const Standard_Integer, const Standard_Integer, const Standard_Boolean, const TColgp_Array1OfPnt2d &, const TColStd_Array1OfReal *, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger &, TColgp_Array1OfPnt2d &, TColStd_Array1OfReal *, TColStd_Array1OfReal &, TColStd_Array1OfInteger &, const Standard_Real)) &BSplCLib::RemoveKnot, "Decrement the multiplicity of <Knots(Index)> to <Mult>. If <Mult> is null the knot is removed.", py::arg("Index"), py::arg("Mult"), py::arg("Degree"), py::arg("Periodic"), py::arg("Poles"), py::arg("Weights"), py::arg("Knots"), py::arg("Mults"), py::arg("NewPoles"), py::arg("NewWeights"), py::arg("NewKnots"), py::arg("NewMults"), py::arg("Tolerance"));
	cls_BSplCLib.def_static("IncreaseDegreeCountKnots_", (Standard_Integer (*)(const Standard_Integer, const Standard_Integer, const Standard_Boolean, const TColStd_Array1OfInteger &)) &BSplCLib::IncreaseDegreeCountKnots, "Returns the number of knots of a curve with multiplicities <Mults> after elevating the degree from <Degree> to <NewDegree>. See the IncreaseDegree method for more comments.", py::arg("Degree"), py::arg("NewDegree"), py::arg("Periodic"), py::arg("Mults"));
	cls_BSplCLib.def_static("IncreaseDegree_", (void (*)(const Standard_Integer, const Standard_Integer, const Standard_Boolean, const Standard_Integer, const TColStd_Array1OfReal &, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger &, TColStd_Array1OfReal &, TColStd_Array1OfReal &, TColStd_Array1OfInteger &)) &BSplCLib::IncreaseDegree, "None", py::arg("Degree"), py::arg("NewDegree"), py::arg("Periodic"), py::arg("Dimension"), py::arg("Poles"), py::arg("Knots"), py::arg("Mults"), py::arg("NewPoles"), py::arg("NewKnots"), py::arg("NewMults"));
	cls_BSplCLib.def_static("IncreaseDegree_", (void (*)(const Standard_Integer, const Standard_Integer, const Standard_Boolean, const TColgp_Array1OfPnt &, const TColStd_Array1OfReal *, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger &, TColgp_Array1OfPnt &, TColStd_Array1OfReal *, TColStd_Array1OfReal &, TColStd_Array1OfInteger &)) &BSplCLib::IncreaseDegree, "None", py::arg("Degree"), py::arg("NewDegree"), py::arg("Periodic"), py::arg("Poles"), py::arg("Weights"), py::arg("Knots"), py::arg("Mults"), py::arg("NewPoles"), py::arg("NewWeights"), py::arg("NewKnots"), py::arg("NewMults"));
	cls_BSplCLib.def_static("IncreaseDegree_", (void (*)(const Standard_Integer, const Standard_Integer, const Standard_Boolean, const TColgp_Array1OfPnt2d &, const TColStd_Array1OfReal *, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger &, TColgp_Array1OfPnt2d &, TColStd_Array1OfReal *, TColStd_Array1OfReal &, TColStd_Array1OfInteger &)) &BSplCLib::IncreaseDegree, "None", py::arg("Degree"), py::arg("NewDegree"), py::arg("Periodic"), py::arg("Poles"), py::arg("Weights"), py::arg("Knots"), py::arg("Mults"), py::arg("NewPoles"), py::arg("NewWeights"), py::arg("NewKnots"), py::arg("NewMults"));
	cls_BSplCLib.def_static("IncreaseDegree_", (void (*)(const Standard_Integer, const TColgp_Array1OfPnt &, const TColStd_Array1OfReal *, TColgp_Array1OfPnt &, TColStd_Array1OfReal *)) &BSplCLib::IncreaseDegree, "None", py::arg("NewDegree"), py::arg("Poles"), py::arg("Weights"), py::arg("NewPoles"), py::arg("NewWeights"));
	cls_BSplCLib.def_static("IncreaseDegree_", (void (*)(const Standard_Integer, const TColgp_Array1OfPnt2d &, const TColStd_Array1OfReal *, TColgp_Array1OfPnt2d &, TColStd_Array1OfReal *)) &BSplCLib::IncreaseDegree, "Increase the degree of a bspline (or bezier) curve of dimension <Dimension> form <Degree> to <NewDegree>.", py::arg("NewDegree"), py::arg("Poles"), py::arg("Weights"), py::arg("NewPoles"), py::arg("NewWeights"));
	cls_BSplCLib.def_static("PrepareUnperiodize_", [](const Standard_Integer Degree, const TColStd_Array1OfInteger & Mults, Standard_Integer & NbKnots, Standard_Integer & NbPoles){ BSplCLib::PrepareUnperiodize(Degree, Mults, NbKnots, NbPoles); return std::tuple<Standard_Integer &, Standard_Integer &>(NbKnots, NbPoles); }, "Set in <NbKnots> and <NbPolesToAdd> the number of Knots and Poles of the NotPeriodic Curve identical at the periodic curve with a degree <Degree> , a knots-distribution with Multiplicities <Mults>.", py::arg("Degree"), py::arg("Mults"), py::arg("NbKnots"), py::arg("NbPoles"));
	cls_BSplCLib.def_static("Unperiodize_", (void (*)(const Standard_Integer, const Standard_Integer, const TColStd_Array1OfInteger &, const TColStd_Array1OfReal &, const TColStd_Array1OfReal &, TColStd_Array1OfInteger &, TColStd_Array1OfReal &, TColStd_Array1OfReal &)) &BSplCLib::Unperiodize, "None", py::arg("Degree"), py::arg("Dimension"), py::arg("Mults"), py::arg("Knots"), py::arg("Poles"), py::arg("NewMults"), py::arg("NewKnots"), py::arg("NewPoles"));
	cls_BSplCLib.def_static("Unperiodize_", (void (*)(const Standard_Integer, const TColStd_Array1OfInteger &, const TColStd_Array1OfReal &, const TColgp_Array1OfPnt &, const TColStd_Array1OfReal *, TColStd_Array1OfInteger &, TColStd_Array1OfReal &, TColgp_Array1OfPnt &, TColStd_Array1OfReal *)) &BSplCLib::Unperiodize, "None", py::arg("Degree"), py::arg("Mults"), py::arg("Knots"), py::arg("Poles"), py::arg("Weights"), py::arg("NewMults"), py::arg("NewKnots"), py::arg("NewPoles"), py::arg("NewWeights"));
	cls_BSplCLib.def_static("Unperiodize_", (void (*)(const Standard_Integer, const TColStd_Array1OfInteger &, const TColStd_Array1OfReal &, const TColgp_Array1OfPnt2d &, const TColStd_Array1OfReal *, TColStd_Array1OfInteger &, TColStd_Array1OfReal &, TColgp_Array1OfPnt2d &, TColStd_Array1OfReal *)) &BSplCLib::Unperiodize, "None", py::arg("Degree"), py::arg("Mults"), py::arg("Knots"), py::arg("Poles"), py::arg("Weights"), py::arg("NewMults"), py::arg("NewKnots"), py::arg("NewPoles"), py::arg("NewWeights"));
	cls_BSplCLib.def_static("PrepareTrimming_", [](const Standard_Integer Degree, const Standard_Boolean Periodic, const TColStd_Array1OfReal & Knots, const TColStd_Array1OfInteger & Mults, const Standard_Real U1, const Standard_Real U2, Standard_Integer & NbKnots, Standard_Integer & NbPoles){ BSplCLib::PrepareTrimming(Degree, Periodic, Knots, Mults, U1, U2, NbKnots, NbPoles); return std::tuple<Standard_Integer &, Standard_Integer &>(NbKnots, NbPoles); }, "Set in <NbKnots> and <NbPoles> the number of Knots and Poles of the curve resulting of the trimming of the BSplinecurve definded with <degree>, <knots>, <mults>", py::arg("Degree"), py::arg("Periodic"), py::arg("Knots"), py::arg("Mults"), py::arg("U1"), py::arg("U2"), py::arg("NbKnots"), py::arg("NbPoles"));
	cls_BSplCLib.def_static("Trimming_", (void (*)(const Standard_Integer, const Standard_Boolean, const Standard_Integer, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger &, const TColStd_Array1OfReal &, const Standard_Real, const Standard_Real, TColStd_Array1OfReal &, TColStd_Array1OfInteger &, TColStd_Array1OfReal &)) &BSplCLib::Trimming, "None", py::arg("Degree"), py::arg("Periodic"), py::arg("Dimension"), py::arg("Knots"), py::arg("Mults"), py::arg("Poles"), py::arg("U1"), py::arg("U2"), py::arg("NewKnots"), py::arg("NewMults"), py::arg("NewPoles"));
	cls_BSplCLib.def_static("Trimming_", (void (*)(const Standard_Integer, const Standard_Boolean, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger &, const TColgp_Array1OfPnt &, const TColStd_Array1OfReal *, const Standard_Real, const Standard_Real, TColStd_Array1OfReal &, TColStd_Array1OfInteger &, TColgp_Array1OfPnt &, TColStd_Array1OfReal *)) &BSplCLib::Trimming, "None", py::arg("Degree"), py::arg("Periodic"), py::arg("Knots"), py::arg("Mults"), py::arg("Poles"), py::arg("Weights"), py::arg("U1"), py::arg("U2"), py::arg("NewKnots"), py::arg("NewMults"), py::arg("NewPoles"), py::arg("NewWeights"));
	cls_BSplCLib.def_static("Trimming_", (void (*)(const Standard_Integer, const Standard_Boolean, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger &, const TColgp_Array1OfPnt2d &, const TColStd_Array1OfReal *, const Standard_Real, const Standard_Real, TColStd_Array1OfReal &, TColStd_Array1OfInteger &, TColgp_Array1OfPnt2d &, TColStd_Array1OfReal *)) &BSplCLib::Trimming, "None", py::arg("Degree"), py::arg("Periodic"), py::arg("Knots"), py::arg("Mults"), py::arg("Poles"), py::arg("Weights"), py::arg("U1"), py::arg("U2"), py::arg("NewKnots"), py::arg("NewMults"), py::arg("NewPoles"), py::arg("NewWeights"));
	cls_BSplCLib.def_static("D0_", [](const Standard_Real U, const Standard_Integer Index, const Standard_Integer Degree, const Standard_Boolean Periodic, const TColStd_Array1OfReal & Poles, const TColStd_Array1OfReal * Weights, const TColStd_Array1OfReal & Knots, const TColStd_Array1OfInteger * Mults, Standard_Real & P){ BSplCLib::D0(U, Index, Degree, Periodic, Poles, Weights, Knots, Mults, P); return P; }, "None", py::arg("U"), py::arg("Index"), py::arg("Degree"), py::arg("Periodic"), py::arg("Poles"), py::arg("Weights"), py::arg("Knots"), py::arg("Mults"), py::arg("P"));
	cls_BSplCLib.def_static("D0_", (void (*)(const Standard_Real, const Standard_Integer, const Standard_Integer, const Standard_Boolean, const TColgp_Array1OfPnt &, const TColStd_Array1OfReal *, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger *, gp_Pnt &)) &BSplCLib::D0, "None", py::arg("U"), py::arg("Index"), py::arg("Degree"), py::arg("Periodic"), py::arg("Poles"), py::arg("Weights"), py::arg("Knots"), py::arg("Mults"), py::arg("P"));
	cls_BSplCLib.def_static("D0_", (void (*)(const Standard_Real, const Standard_Integer, const Standard_Integer, const Standard_Boolean, const TColgp_Array1OfPnt2d &, const TColStd_Array1OfReal *, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger *, gp_Pnt2d &)) &BSplCLib::D0, "None", py::arg("U"), py::arg("UIndex"), py::arg("Degree"), py::arg("Periodic"), py::arg("Poles"), py::arg("Weights"), py::arg("Knots"), py::arg("Mults"), py::arg("P"));
	cls_BSplCLib.def_static("D0_", (void (*)(const Standard_Real, const TColgp_Array1OfPnt &, const TColStd_Array1OfReal *, gp_Pnt &)) &BSplCLib::D0, "None", py::arg("U"), py::arg("Poles"), py::arg("Weights"), py::arg("P"));
	cls_BSplCLib.def_static("D0_", (void (*)(const Standard_Real, const TColgp_Array1OfPnt2d &, const TColStd_Array1OfReal *, gp_Pnt2d &)) &BSplCLib::D0, "None", py::arg("U"), py::arg("Poles"), py::arg("Weights"), py::arg("P"));
	cls_BSplCLib.def_static("D1_", [](const Standard_Real U, const Standard_Integer Index, const Standard_Integer Degree, const Standard_Boolean Periodic, const TColStd_Array1OfReal & Poles, const TColStd_Array1OfReal * Weights, const TColStd_Array1OfReal & Knots, const TColStd_Array1OfInteger * Mults, Standard_Real & P, Standard_Real & V){ BSplCLib::D1(U, Index, Degree, Periodic, Poles, Weights, Knots, Mults, P, V); return std::tuple<Standard_Real &, Standard_Real &>(P, V); }, "None", py::arg("U"), py::arg("Index"), py::arg("Degree"), py::arg("Periodic"), py::arg("Poles"), py::arg("Weights"), py::arg("Knots"), py::arg("Mults"), py::arg("P"), py::arg("V"));
	cls_BSplCLib.def_static("D1_", (void (*)(const Standard_Real, const Standard_Integer, const Standard_Integer, const Standard_Boolean, const TColgp_Array1OfPnt &, const TColStd_Array1OfReal *, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger *, gp_Pnt &, gp_Vec &)) &BSplCLib::D1, "None", py::arg("U"), py::arg("Index"), py::arg("Degree"), py::arg("Periodic"), py::arg("Poles"), py::arg("Weights"), py::arg("Knots"), py::arg("Mults"), py::arg("P"), py::arg("V"));
	cls_BSplCLib.def_static("D1_", (void (*)(const Standard_Real, const Standard_Integer, const Standard_Integer, const Standard_Boolean, const TColgp_Array1OfPnt2d &, const TColStd_Array1OfReal *, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger *, gp_Pnt2d &, gp_Vec2d &)) &BSplCLib::D1, "None", py::arg("U"), py::arg("UIndex"), py::arg("Degree"), py::arg("Periodic"), py::arg("Poles"), py::arg("Weights"), py::arg("Knots"), py::arg("Mults"), py::arg("P"), py::arg("V"));
	cls_BSplCLib.def_static("D1_", (void (*)(const Standard_Real, const TColgp_Array1OfPnt &, const TColStd_Array1OfReal *, gp_Pnt &, gp_Vec &)) &BSplCLib::D1, "None", py::arg("U"), py::arg("Poles"), py::arg("Weights"), py::arg("P"), py::arg("V"));
	cls_BSplCLib.def_static("D1_", (void (*)(const Standard_Real, const TColgp_Array1OfPnt2d &, const TColStd_Array1OfReal *, gp_Pnt2d &, gp_Vec2d &)) &BSplCLib::D1, "None", py::arg("U"), py::arg("Poles"), py::arg("Weights"), py::arg("P"), py::arg("V"));
	cls_BSplCLib.def_static("D2_", [](const Standard_Real U, const Standard_Integer Index, const Standard_Integer Degree, const Standard_Boolean Periodic, const TColStd_Array1OfReal & Poles, const TColStd_Array1OfReal * Weights, const TColStd_Array1OfReal & Knots, const TColStd_Array1OfInteger * Mults, Standard_Real & P, Standard_Real & V1, Standard_Real & V2){ BSplCLib::D2(U, Index, Degree, Periodic, Poles, Weights, Knots, Mults, P, V1, V2); return std::tuple<Standard_Real &, Standard_Real &, Standard_Real &>(P, V1, V2); }, "None", py::arg("U"), py::arg("Index"), py::arg("Degree"), py::arg("Periodic"), py::arg("Poles"), py::arg("Weights"), py::arg("Knots"), py::arg("Mults"), py::arg("P"), py::arg("V1"), py::arg("V2"));
	cls_BSplCLib.def_static("D2_", (void (*)(const Standard_Real, const Standard_Integer, const Standard_Integer, const Standard_Boolean, const TColgp_Array1OfPnt &, const TColStd_Array1OfReal *, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger *, gp_Pnt &, gp_Vec &, gp_Vec &)) &BSplCLib::D2, "None", py::arg("U"), py::arg("Index"), py::arg("Degree"), py::arg("Periodic"), py::arg("Poles"), py::arg("Weights"), py::arg("Knots"), py::arg("Mults"), py::arg("P"), py::arg("V1"), py::arg("V2"));
	cls_BSplCLib.def_static("D2_", (void (*)(const Standard_Real, const Standard_Integer, const Standard_Integer, const Standard_Boolean, const TColgp_Array1OfPnt2d &, const TColStd_Array1OfReal *, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger *, gp_Pnt2d &, gp_Vec2d &, gp_Vec2d &)) &BSplCLib::D2, "None", py::arg("U"), py::arg("UIndex"), py::arg("Degree"), py::arg("Periodic"), py::arg("Poles"), py::arg("Weights"), py::arg("Knots"), py::arg("Mults"), py::arg("P"), py::arg("V1"), py::arg("V2"));
	cls_BSplCLib.def_static("D2_", (void (*)(const Standard_Real, const TColgp_Array1OfPnt &, const TColStd_Array1OfReal *, gp_Pnt &, gp_Vec &, gp_Vec &)) &BSplCLib::D2, "None", py::arg("U"), py::arg("Poles"), py::arg("Weights"), py::arg("P"), py::arg("V1"), py::arg("V2"));
	cls_BSplCLib.def_static("D2_", (void (*)(const Standard_Real, const TColgp_Array1OfPnt2d &, const TColStd_Array1OfReal *, gp_Pnt2d &, gp_Vec2d &, gp_Vec2d &)) &BSplCLib::D2, "None", py::arg("U"), py::arg("Poles"), py::arg("Weights"), py::arg("P"), py::arg("V1"), py::arg("V2"));
	cls_BSplCLib.def_static("D3_", [](const Standard_Real U, const Standard_Integer Index, const Standard_Integer Degree, const Standard_Boolean Periodic, const TColStd_Array1OfReal & Poles, const TColStd_Array1OfReal * Weights, const TColStd_Array1OfReal & Knots, const TColStd_Array1OfInteger * Mults, Standard_Real & P, Standard_Real & V1, Standard_Real & V2, Standard_Real & V3){ BSplCLib::D3(U, Index, Degree, Periodic, Poles, Weights, Knots, Mults, P, V1, V2, V3); return std::tuple<Standard_Real &, Standard_Real &, Standard_Real &, Standard_Real &>(P, V1, V2, V3); }, "None", py::arg("U"), py::arg("Index"), py::arg("Degree"), py::arg("Periodic"), py::arg("Poles"), py::arg("Weights"), py::arg("Knots"), py::arg("Mults"), py::arg("P"), py::arg("V1"), py::arg("V2"), py::arg("V3"));
	cls_BSplCLib.def_static("D3_", (void (*)(const Standard_Real, const Standard_Integer, const Standard_Integer, const Standard_Boolean, const TColgp_Array1OfPnt &, const TColStd_Array1OfReal *, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger *, gp_Pnt &, gp_Vec &, gp_Vec &, gp_Vec &)) &BSplCLib::D3, "None", py::arg("U"), py::arg("Index"), py::arg("Degree"), py::arg("Periodic"), py::arg("Poles"), py::arg("Weights"), py::arg("Knots"), py::arg("Mults"), py::arg("P"), py::arg("V1"), py::arg("V2"), py::arg("V3"));
	cls_BSplCLib.def_static("D3_", (void (*)(const Standard_Real, const Standard_Integer, const Standard_Integer, const Standard_Boolean, const TColgp_Array1OfPnt2d &, const TColStd_Array1OfReal *, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger *, gp_Pnt2d &, gp_Vec2d &, gp_Vec2d &, gp_Vec2d &)) &BSplCLib::D3, "None", py::arg("U"), py::arg("UIndex"), py::arg("Degree"), py::arg("Periodic"), py::arg("Poles"), py::arg("Weights"), py::arg("Knots"), py::arg("Mults"), py::arg("P"), py::arg("V1"), py::arg("V2"), py::arg("V3"));
	cls_BSplCLib.def_static("D3_", (void (*)(const Standard_Real, const TColgp_Array1OfPnt &, const TColStd_Array1OfReal *, gp_Pnt &, gp_Vec &, gp_Vec &, gp_Vec &)) &BSplCLib::D3, "None", py::arg("U"), py::arg("Poles"), py::arg("Weights"), py::arg("P"), py::arg("V1"), py::arg("V2"), py::arg("V3"));
	cls_BSplCLib.def_static("D3_", (void (*)(const Standard_Real, const TColgp_Array1OfPnt2d &, const TColStd_Array1OfReal *, gp_Pnt2d &, gp_Vec2d &, gp_Vec2d &, gp_Vec2d &)) &BSplCLib::D3, "None", py::arg("U"), py::arg("Poles"), py::arg("Weights"), py::arg("P"), py::arg("V1"), py::arg("V2"), py::arg("V3"));
	cls_BSplCLib.def_static("DN_", [](const Standard_Real U, const Standard_Integer N, const Standard_Integer Index, const Standard_Integer Degree, const Standard_Boolean Periodic, const TColStd_Array1OfReal & Poles, const TColStd_Array1OfReal * Weights, const TColStd_Array1OfReal & Knots, const TColStd_Array1OfInteger * Mults, Standard_Real & VN){ BSplCLib::DN(U, N, Index, Degree, Periodic, Poles, Weights, Knots, Mults, VN); return VN; }, "None", py::arg("U"), py::arg("N"), py::arg("Index"), py::arg("Degree"), py::arg("Periodic"), py::arg("Poles"), py::arg("Weights"), py::arg("Knots"), py::arg("Mults"), py::arg("VN"));
	cls_BSplCLib.def_static("DN_", (void (*)(const Standard_Real, const Standard_Integer, const Standard_Integer, const Standard_Integer, const Standard_Boolean, const TColgp_Array1OfPnt &, const TColStd_Array1OfReal *, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger *, gp_Vec &)) &BSplCLib::DN, "None", py::arg("U"), py::arg("N"), py::arg("Index"), py::arg("Degree"), py::arg("Periodic"), py::arg("Poles"), py::arg("Weights"), py::arg("Knots"), py::arg("Mults"), py::arg("VN"));
	cls_BSplCLib.def_static("DN_", (void (*)(const Standard_Real, const Standard_Integer, const Standard_Integer, const Standard_Integer, const Standard_Boolean, const TColgp_Array1OfPnt2d &, const TColStd_Array1OfReal *, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger *, gp_Vec2d &)) &BSplCLib::DN, "None", py::arg("U"), py::arg("N"), py::arg("UIndex"), py::arg("Degree"), py::arg("Periodic"), py::arg("Poles"), py::arg("Weights"), py::arg("Knots"), py::arg("Mults"), py::arg("V"));
	// cls_BSplCLib.def_static("DN_", (void (*)(const Standard_Real, const Standard_Integer, const TColgp_Array1OfPnt &, const TColStd_Array1OfReal &, gp_Pnt &, gp_Vec &)) &BSplCLib::DN, "None", py::arg("U"), py::arg("N"), py::arg("Poles"), py::arg("Weights"), py::arg("P"), py::arg("VN"));
	// cls_BSplCLib.def_static("DN_", (void (*)(const Standard_Real, const Standard_Integer, const TColgp_Array1OfPnt2d &, const TColStd_Array1OfReal &, gp_Pnt2d &, gp_Vec2d &)) &BSplCLib::DN, "The above functions compute values and derivatives in the following situations :", py::arg("U"), py::arg("N"), py::arg("Poles"), py::arg("Weights"), py::arg("P"), py::arg("VN"));
	cls_BSplCLib.def_static("EvalBsplineBasis_", [](const Standard_Integer DerivativeOrder, const Standard_Integer Order, const TColStd_Array1OfReal & FlatKnots, const Standard_Real Parameter, Standard_Integer & FirstNonZeroBsplineIndex, math_Matrix & BsplineBasis, const Standard_Boolean isPeriodic){ Standard_Integer rv = BSplCLib::EvalBsplineBasis(DerivativeOrder, Order, FlatKnots, Parameter, FirstNonZeroBsplineIndex, BsplineBasis, isPeriodic); return std::tuple<Standard_Integer, Standard_Integer &>(rv, FirstNonZeroBsplineIndex); }, "This evaluates the Bspline Basis at a given parameter Parameter up to the requested DerivativeOrder and store the result in the array BsplineBasis in the following fashion BSplineBasis(1,1) = value of first non vanishing Bspline function which has Index FirstNonZeroBsplineIndex BsplineBasis(1,2) = value of second non vanishing Bspline function which has Index FirstNonZeroBsplineIndex + 1 BsplineBasis(1,n) = value of second non vanishing non vanishing Bspline function which has Index FirstNonZeroBsplineIndex + n (n <= Order) BSplineBasis(2,1) = value of derivative of first non vanishing Bspline function which has Index FirstNonZeroBsplineIndex BSplineBasis(N,1) = value of Nth derivative of first non vanishing Bspline function which has Index FirstNonZeroBsplineIndex if N <= DerivativeOrder + 1", py::arg("DerivativeOrder"), py::arg("Order"), py::arg("FlatKnots"), py::arg("Parameter"), py::arg("FirstNonZeroBsplineIndex"), py::arg("BsplineBasis"), py::arg("isPeriodic"));
	cls_BSplCLib.def_static("BuildBSpMatrix_", [](const TColStd_Array1OfReal & Parameters, const TColStd_Array1OfInteger & OrderArray, const TColStd_Array1OfReal & FlatKnots, const Standard_Integer Degree, math_Matrix & Matrix, Standard_Integer & UpperBandWidth, Standard_Integer & LowerBandWidth){ Standard_Integer rv = BSplCLib::BuildBSpMatrix(Parameters, OrderArray, FlatKnots, Degree, Matrix, UpperBandWidth, LowerBandWidth); return std::tuple<Standard_Integer, Standard_Integer &, Standard_Integer &>(rv, UpperBandWidth, LowerBandWidth); }, "This Builds a fully blown Matrix of (ni) Bi (tj)", py::arg("Parameters"), py::arg("OrderArray"), py::arg("FlatKnots"), py::arg("Degree"), py::arg("Matrix"), py::arg("UpperBandWidth"), py::arg("LowerBandWidth"));
	cls_BSplCLib.def_static("FactorBandedMatrix_", [](math_Matrix & Matrix, const Standard_Integer UpperBandWidth, const Standard_Integer LowerBandWidth, Standard_Integer & PivotIndexProblem){ Standard_Integer rv = BSplCLib::FactorBandedMatrix(Matrix, UpperBandWidth, LowerBandWidth, PivotIndexProblem); return std::tuple<Standard_Integer, Standard_Integer &>(rv, PivotIndexProblem); }, "this factors the Banded Matrix in the LU form with a Banded storage of components of the L matrix WARNING : do not use if the Matrix is totally positive (It is the case for Bspline matrices build as above with parameters being the Schoenberg points", py::arg("Matrix"), py::arg("UpperBandWidth"), py::arg("LowerBandWidth"), py::arg("PivotIndexProblem"));
	cls_BSplCLib.def_static("SolveBandedSystem_", [](const math_Matrix & Matrix, const Standard_Integer UpperBandWidth, const Standard_Integer LowerBandWidth, const Standard_Integer ArrayDimension, Standard_Real & Array){ Standard_Integer rv = BSplCLib::SolveBandedSystem(Matrix, UpperBandWidth, LowerBandWidth, ArrayDimension, Array); return std::tuple<Standard_Integer, Standard_Real &>(rv, Array); }, "This solves the system Matrix.X = B with when Matrix is factored in LU form The Array is an seen as an Array[1..N][1..ArrayDimension] with N = the rank of the matrix Matrix. The result is stored in Array when each coordinate is solved that is B is the array whose values are B[i] = Array[i][p] for each p in 1..ArrayDimension", py::arg("Matrix"), py::arg("UpperBandWidth"), py::arg("LowerBandWidth"), py::arg("ArrayDimension"), py::arg("Array"));
	cls_BSplCLib.def_static("SolveBandedSystem_", (Standard_Integer (*)(const math_Matrix &, const Standard_Integer, const Standard_Integer, TColgp_Array1OfPnt2d &)) &BSplCLib::SolveBandedSystem, "This solves the system Matrix.X = B with when Matrix is factored in LU form The Array has the length of the rank of the matrix Matrix. The result is stored in Array when each coordinate is solved that is B is the array whose values are B[i] = Array[i][p] for each p in 1..ArrayDimension", py::arg("Matrix"), py::arg("UpperBandWidth"), py::arg("LowerBandWidth"), py::arg("Array"));
	cls_BSplCLib.def_static("SolveBandedSystem_", (Standard_Integer (*)(const math_Matrix &, const Standard_Integer, const Standard_Integer, TColgp_Array1OfPnt &)) &BSplCLib::SolveBandedSystem, "This solves the system Matrix.X = B with when Matrix is factored in LU form The Array has the length of the rank of the matrix Matrix. The result is stored in Array when each coordinate is solved that is B is the array whose values are B[i] = Array[i][p] for each p in 1..ArrayDimension", py::arg("Matrix"), py::arg("UpperBandWidth"), py::arg("LowerBandWidth"), py::arg("Array"));
	cls_BSplCLib.def_static("SolveBandedSystem_", [](const math_Matrix & Matrix, const Standard_Integer UpperBandWidth, const Standard_Integer LowerBandWidth, const Standard_Boolean HomogenousFlag, const Standard_Integer ArrayDimension, Standard_Real & Array, Standard_Real & Weights){ Standard_Integer rv = BSplCLib::SolveBandedSystem(Matrix, UpperBandWidth, LowerBandWidth, HomogenousFlag, ArrayDimension, Array, Weights); return std::tuple<Standard_Integer, Standard_Real &, Standard_Real &>(rv, Array, Weights); }, "None", py::arg("Matrix"), py::arg("UpperBandWidth"), py::arg("LowerBandWidth"), py::arg("HomogenousFlag"), py::arg("ArrayDimension"), py::arg("Array"), py::arg("Weights"));
	cls_BSplCLib.def_static("SolveBandedSystem_", (Standard_Integer (*)(const math_Matrix &, const Standard_Integer, const Standard_Integer, const Standard_Boolean, TColgp_Array1OfPnt2d &, TColStd_Array1OfReal &)) &BSplCLib::SolveBandedSystem, "This solves the system Matrix.X = B with when Matrix is factored in LU form The Array is an seen as an Array[1..N][1..ArrayDimension] with N = the rank of the matrix Matrix. The result is stored in Array when each coordinate is solved that is B is the array whose values are B[i] = Array[i][p] for each p in 1..ArrayDimension. If HomogeneousFlag == 0 the Poles are multiplied by the Weights uppon Entry and once interpolation is carried over the result of the poles are divided by the result of the interpolation of the weights. Otherwise if HomogenousFlag == 1 the Poles and Weigths are treated homogenously that is that those are interpolated as they are and result is returned without division by the interpolated weigths.", py::arg("Matrix"), py::arg("UpperBandWidth"), py::arg("LowerBandWidth"), py::arg("HomogenousFlag"), py::arg("Array"), py::arg("Weights"));
	cls_BSplCLib.def_static("SolveBandedSystem_", (Standard_Integer (*)(const math_Matrix &, const Standard_Integer, const Standard_Integer, const Standard_Boolean, TColgp_Array1OfPnt &, TColStd_Array1OfReal &)) &BSplCLib::SolveBandedSystem, "This solves the system Matrix.X = B with when Matrix is factored in LU form The Array is an seen as an Array[1..N][1..ArrayDimension] with N = the rank of the matrix Matrix. The result is stored in Array when each coordinate is solved that is B is the array whose values are B[i] = Array[i][p] for each p in 1..ArrayDimension If HomogeneousFlag == 0 the Poles are multiplied by the Weights uppon Entry and once interpolation is carried over the result of the poles are divided by the result of the interpolation of the weights. Otherwise if HomogenousFlag == 1 the Poles and Weigths are treated homogenously that is that those are interpolated as they are and result is returned without division by the interpolated weigths.", py::arg("Matrix"), py::arg("UpperBandWidth"), py::arg("LowerBandWidth"), py::arg("HomogeneousFlag"), py::arg("Array"), py::arg("Weights"));
	cls_BSplCLib.def_static("MergeBSplineKnots_", [](const Standard_Real Tolerance, const Standard_Real StartValue, const Standard_Real EndValue, const Standard_Integer Degree1, const TColStd_Array1OfReal & Knots1, const TColStd_Array1OfInteger & Mults1, const Standard_Integer Degree2, const TColStd_Array1OfReal & Knots2, const TColStd_Array1OfInteger & Mults2, Standard_Integer & NumPoles, opencascade::handle<TColStd_HArray1OfReal> & NewKnots, opencascade::handle<TColStd_HArray1OfInteger> & NewMults){ BSplCLib::MergeBSplineKnots(Tolerance, StartValue, EndValue, Degree1, Knots1, Mults1, Degree2, Knots2, Mults2, NumPoles, NewKnots, NewMults); return NumPoles; }, "Merges two knot vector by setting the starting and ending values to StartValue and EndValue", py::arg("Tolerance"), py::arg("StartValue"), py::arg("EndValue"), py::arg("Degree1"), py::arg("Knots1"), py::arg("Mults1"), py::arg("Degree2"), py::arg("Knots2"), py::arg("Mults2"), py::arg("NumPoles"), py::arg("NewKnots"), py::arg("NewMults"));
	cls_BSplCLib.def_static("FunctionReparameterise_", [](const BSplCLib_EvaluatorFunction & Function, const Standard_Integer BSplineDegree, const TColStd_Array1OfReal & BSplineFlatKnots, const Standard_Integer PolesDimension, Standard_Real & Poles, const TColStd_Array1OfReal & FlatKnots, const Standard_Integer NewDegree, Standard_Real & NewPoles, Standard_Integer & theStatus){ BSplCLib::FunctionReparameterise(Function, BSplineDegree, BSplineFlatKnots, PolesDimension, Poles, FlatKnots, NewDegree, NewPoles, theStatus); return std::tuple<Standard_Real &, Standard_Real &, Standard_Integer &>(Poles, NewPoles, theStatus); }, "This function will compose a given Vectorial BSpline F(t) defined by its BSplineDegree and BSplineFlatKnotsl, its Poles array which are coded as an array of Real of the form [1..NumPoles][1..PolesDimension] with a function a(t) which is assumed to satisfy the following:", py::arg("Function"), py::arg("BSplineDegree"), py::arg("BSplineFlatKnots"), py::arg("PolesDimension"), py::arg("Poles"), py::arg("FlatKnots"), py::arg("NewDegree"), py::arg("NewPoles"), py::arg("theStatus"));
	cls_BSplCLib.def_static("FunctionReparameterise_", [](const BSplCLib_EvaluatorFunction & Function, const Standard_Integer BSplineDegree, const TColStd_Array1OfReal & BSplineFlatKnots, const TColStd_Array1OfReal & Poles, const TColStd_Array1OfReal & FlatKnots, const Standard_Integer NewDegree, TColStd_Array1OfReal & NewPoles, Standard_Integer & theStatus){ BSplCLib::FunctionReparameterise(Function, BSplineDegree, BSplineFlatKnots, Poles, FlatKnots, NewDegree, NewPoles, theStatus); return theStatus; }, "This function will compose a given Vectorial BSpline F(t) defined by its BSplineDegree and BSplineFlatKnotsl, its Poles array which are coded as an array of Real of the form [1..NumPoles][1..PolesDimension] with a function a(t) which is assumed to satisfy the following:", py::arg("Function"), py::arg("BSplineDegree"), py::arg("BSplineFlatKnots"), py::arg("Poles"), py::arg("FlatKnots"), py::arg("NewDegree"), py::arg("NewPoles"), py::arg("theStatus"));
	cls_BSplCLib.def_static("FunctionReparameterise_", [](const BSplCLib_EvaluatorFunction & Function, const Standard_Integer BSplineDegree, const TColStd_Array1OfReal & BSplineFlatKnots, const TColgp_Array1OfPnt & Poles, const TColStd_Array1OfReal & FlatKnots, const Standard_Integer NewDegree, TColgp_Array1OfPnt & NewPoles, Standard_Integer & theStatus){ BSplCLib::FunctionReparameterise(Function, BSplineDegree, BSplineFlatKnots, Poles, FlatKnots, NewDegree, NewPoles, theStatus); return theStatus; }, "this will compose a given Vectorial BSpline F(t) defined by its BSplineDegree and BSplineFlatKnotsl, its Poles array which are coded as an array of Real of the form [1..NumPoles][1..PolesDimension] with a function a(t) which is assumed to satisfy the following : 1. F(a(t)) is a polynomial BSpline that can be expressed exactly as a BSpline of degree NewDegree on the knots FlatKnots 2. a(t) defines a differentiable isomorphism between the range of FlatKnots to the range of BSplineFlatKnots which is the same as the range of F(t) Warning: it is the caller's responsability to insure that conditions 1. and 2. above are satisfied : no check whatsoever is made in this method theStatus will return 0 if OK else it will return the pivot index of the matrix that was inverted to compute the multiplied BSpline : the method used is interpolation at Schoenenberg points of F(a(t))", py::arg("Function"), py::arg("BSplineDegree"), py::arg("BSplineFlatKnots"), py::arg("Poles"), py::arg("FlatKnots"), py::arg("NewDegree"), py::arg("NewPoles"), py::arg("theStatus"));
	cls_BSplCLib.def_static("FunctionReparameterise_", [](const BSplCLib_EvaluatorFunction & Function, const Standard_Integer BSplineDegree, const TColStd_Array1OfReal & BSplineFlatKnots, const TColgp_Array1OfPnt2d & Poles, const TColStd_Array1OfReal & FlatKnots, const Standard_Integer NewDegree, TColgp_Array1OfPnt2d & NewPoles, Standard_Integer & theStatus){ BSplCLib::FunctionReparameterise(Function, BSplineDegree, BSplineFlatKnots, Poles, FlatKnots, NewDegree, NewPoles, theStatus); return theStatus; }, "this will compose a given Vectorial BSpline F(t) defined by its BSplineDegree and BSplineFlatKnotsl, its Poles array which are coded as an array of Real of the form [1..NumPoles][1..PolesDimension] with a function a(t) which is assumed to satisfy the following : 1. F(a(t)) is a polynomial BSpline that can be expressed exactly as a BSpline of degree NewDegree on the knots FlatKnots 2. a(t) defines a differentiable isomorphism between the range of FlatKnots to the range of BSplineFlatKnots which is the same as the range of F(t) Warning: it is the caller's responsability to insure that conditions 1. and 2. above are satisfied : no check whatsoever is made in this method theStatus will return 0 if OK else it will return the pivot index of the matrix that was inverted to compute the multiplied BSpline : the method used is interpolation at Schoenenberg points of F(a(t))", py::arg("Function"), py::arg("BSplineDegree"), py::arg("BSplineFlatKnots"), py::arg("Poles"), py::arg("FlatKnots"), py::arg("NewDegree"), py::arg("NewPoles"), py::arg("theStatus"));
	cls_BSplCLib.def_static("FunctionMultiply_", [](const BSplCLib_EvaluatorFunction & Function, const Standard_Integer BSplineDegree, const TColStd_Array1OfReal & BSplineFlatKnots, const Standard_Integer PolesDimension, Standard_Real & Poles, const TColStd_Array1OfReal & FlatKnots, const Standard_Integer NewDegree, Standard_Real & NewPoles, Standard_Integer & theStatus){ BSplCLib::FunctionMultiply(Function, BSplineDegree, BSplineFlatKnots, PolesDimension, Poles, FlatKnots, NewDegree, NewPoles, theStatus); return std::tuple<Standard_Real &, Standard_Real &, Standard_Integer &>(Poles, NewPoles, theStatus); }, "this will multiply a given Vectorial BSpline F(t) defined by its BSplineDegree and BSplineFlatKnotsl, its Poles array which are coded as an array of Real of the form [1..NumPoles][1..PolesDimension] by a function a(t) which is assumed to satisfy the following : 1. a(t) * F(t) is a polynomial BSpline that can be expressed exactly as a BSpline of degree NewDegree on the knots FlatKnots 2. the range of a(t) is the same as the range of F(t) Warning: it is the caller's responsability to insure that conditions 1. and 2. above are satisfied : no check whatsoever is made in this method theStatus will return 0 if OK else it will return the pivot index of the matrix that was inverted to compute the multiplied BSpline : the method used is interpolation at Schoenenberg points of a(t)*F(t)", py::arg("Function"), py::arg("BSplineDegree"), py::arg("BSplineFlatKnots"), py::arg("PolesDimension"), py::arg("Poles"), py::arg("FlatKnots"), py::arg("NewDegree"), py::arg("NewPoles"), py::arg("theStatus"));
	cls_BSplCLib.def_static("FunctionMultiply_", [](const BSplCLib_EvaluatorFunction & Function, const Standard_Integer BSplineDegree, const TColStd_Array1OfReal & BSplineFlatKnots, const TColStd_Array1OfReal & Poles, const TColStd_Array1OfReal & FlatKnots, const Standard_Integer NewDegree, TColStd_Array1OfReal & NewPoles, Standard_Integer & theStatus){ BSplCLib::FunctionMultiply(Function, BSplineDegree, BSplineFlatKnots, Poles, FlatKnots, NewDegree, NewPoles, theStatus); return theStatus; }, "this will multiply a given Vectorial BSpline F(t) defined by its BSplineDegree and BSplineFlatKnotsl, its Poles array which are coded as an array of Real of the form [1..NumPoles][1..PolesDimension] by a function a(t) which is assumed to satisfy the following : 1. a(t) * F(t) is a polynomial BSpline that can be expressed exactly as a BSpline of degree NewDegree on the knots FlatKnots 2. the range of a(t) is the same as the range of F(t) Warning: it is the caller's responsability to insure that conditions 1. and 2. above are satisfied : no check whatsoever is made in this method theStatus will return 0 if OK else it will return the pivot index of the matrix that was inverted to compute the multiplied BSpline : the method used is interpolation at Schoenenberg points of a(t)*F(t)", py::arg("Function"), py::arg("BSplineDegree"), py::arg("BSplineFlatKnots"), py::arg("Poles"), py::arg("FlatKnots"), py::arg("NewDegree"), py::arg("NewPoles"), py::arg("theStatus"));
	cls_BSplCLib.def_static("FunctionMultiply_", [](const BSplCLib_EvaluatorFunction & Function, const Standard_Integer BSplineDegree, const TColStd_Array1OfReal & BSplineFlatKnots, const TColgp_Array1OfPnt2d & Poles, const TColStd_Array1OfReal & FlatKnots, const Standard_Integer NewDegree, TColgp_Array1OfPnt2d & NewPoles, Standard_Integer & theStatus){ BSplCLib::FunctionMultiply(Function, BSplineDegree, BSplineFlatKnots, Poles, FlatKnots, NewDegree, NewPoles, theStatus); return theStatus; }, "this will multiply a given Vectorial BSpline F(t) defined by its BSplineDegree and BSplineFlatKnotsl, its Poles array which are coded as an array of Real of the form [1..NumPoles][1..PolesDimension] by a function a(t) which is assumed to satisfy the following : 1. a(t) * F(t) is a polynomial BSpline that can be expressed exactly as a BSpline of degree NewDegree on the knots FlatKnots 2. the range of a(t) is the same as the range of F(t) Warning: it is the caller's responsability to insure that conditions 1. and 2. above are satisfied : no check whatsoever is made in this method theStatus will return 0 if OK else it will return the pivot index of the matrix that was inverted to compute the multiplied BSpline : the method used is interpolation at Schoenenberg points of a(t)*F(t)", py::arg("Function"), py::arg("BSplineDegree"), py::arg("BSplineFlatKnots"), py::arg("Poles"), py::arg("FlatKnots"), py::arg("NewDegree"), py::arg("NewPoles"), py::arg("theStatus"));
	cls_BSplCLib.def_static("FunctionMultiply_", [](const BSplCLib_EvaluatorFunction & Function, const Standard_Integer BSplineDegree, const TColStd_Array1OfReal & BSplineFlatKnots, const TColgp_Array1OfPnt & Poles, const TColStd_Array1OfReal & FlatKnots, const Standard_Integer NewDegree, TColgp_Array1OfPnt & NewPoles, Standard_Integer & theStatus){ BSplCLib::FunctionMultiply(Function, BSplineDegree, BSplineFlatKnots, Poles, FlatKnots, NewDegree, NewPoles, theStatus); return theStatus; }, "this will multiply a given Vectorial BSpline F(t) defined by its BSplineDegree and BSplineFlatKnotsl, its Poles array which are coded as an array of Real of the form [1..NumPoles][1..PolesDimension] by a function a(t) which is assumed to satisfy the following : 1. a(t) * F(t) is a polynomial BSpline that can be expressed exactly as a BSpline of degree NewDegree on the knots FlatKnots 2. the range of a(t) is the same as the range of F(t) Warning: it is the caller's responsability to insure that conditions 1. and 2. above are satisfied : no check whatsoever is made in this method theStatus will return 0 if OK else it will return the pivot index of the matrix that was inverted to compute the multiplied BSpline : the method used is interpolation at Schoenenberg points of a(t)*F(t)", py::arg("Function"), py::arg("BSplineDegree"), py::arg("BSplineFlatKnots"), py::arg("Poles"), py::arg("FlatKnots"), py::arg("NewDegree"), py::arg("NewPoles"), py::arg("theStatus"));
	cls_BSplCLib.def_static("Eval_", [](const Standard_Real U, const Standard_Boolean PeriodicFlag, const Standard_Integer DerivativeRequest, Standard_Integer & ExtrapMode, const Standard_Integer Degree, const TColStd_Array1OfReal & FlatKnots, const Standard_Integer ArrayDimension, Standard_Real & Poles, Standard_Real & Result){ BSplCLib::Eval(U, PeriodicFlag, DerivativeRequest, ExtrapMode, Degree, FlatKnots, ArrayDimension, Poles, Result); return std::tuple<Standard_Integer &, Standard_Real &, Standard_Real &>(ExtrapMode, Poles, Result); }, "Perform the De Boor algorithm to evaluate a point at parameter <U>, with <Degree> and <Dimension>.", py::arg("U"), py::arg("PeriodicFlag"), py::arg("DerivativeRequest"), py::arg("ExtrapMode"), py::arg("Degree"), py::arg("FlatKnots"), py::arg("ArrayDimension"), py::arg("Poles"), py::arg("Result"));
	cls_BSplCLib.def_static("Eval_", [](const Standard_Real U, const Standard_Boolean PeriodicFlag, const Standard_Integer DerivativeRequest, Standard_Integer & ExtrapMode, const Standard_Integer Degree, const TColStd_Array1OfReal & FlatKnots, const Standard_Integer ArrayDimension, Standard_Real & Poles, Standard_Real & Weights, Standard_Real & PolesResult, Standard_Real & WeightsResult){ BSplCLib::Eval(U, PeriodicFlag, DerivativeRequest, ExtrapMode, Degree, FlatKnots, ArrayDimension, Poles, Weights, PolesResult, WeightsResult); return std::tuple<Standard_Integer &, Standard_Real &, Standard_Real &, Standard_Real &, Standard_Real &>(ExtrapMode, Poles, Weights, PolesResult, WeightsResult); }, "Perform the De Boor algorithm to evaluate a point at parameter <U>, with <Degree> and <Dimension>. Evaluates by multiplying the Poles by the Weights and gives the homogeneous result in PolesResult that is the results of the evaluation of the numerator once it has been multiplied by the weights and in WeightsResult one has the result of the evaluation of the denominator", py::arg("U"), py::arg("PeriodicFlag"), py::arg("DerivativeRequest"), py::arg("ExtrapMode"), py::arg("Degree"), py::arg("FlatKnots"), py::arg("ArrayDimension"), py::arg("Poles"), py::arg("Weights"), py::arg("PolesResult"), py::arg("WeightsResult"));
	cls_BSplCLib.def_static("Eval_", [](const Standard_Real U, const Standard_Boolean PeriodicFlag, const Standard_Boolean HomogeneousFlag, Standard_Integer & ExtrapMode, const Standard_Integer Degree, const TColStd_Array1OfReal & FlatKnots, const TColgp_Array1OfPnt & Poles, const TColStd_Array1OfReal & Weights, gp_Pnt & Point, Standard_Real & Weight){ BSplCLib::Eval(U, PeriodicFlag, HomogeneousFlag, ExtrapMode, Degree, FlatKnots, Poles, Weights, Point, Weight); return std::tuple<Standard_Integer &, Standard_Real &>(ExtrapMode, Weight); }, "Perform the evaluation of the Bspline Basis and then multiplies by the weights this just evaluates the current point", py::arg("U"), py::arg("PeriodicFlag"), py::arg("HomogeneousFlag"), py::arg("ExtrapMode"), py::arg("Degree"), py::arg("FlatKnots"), py::arg("Poles"), py::arg("Weights"), py::arg("Point"), py::arg("Weight"));
	cls_BSplCLib.def_static("Eval_", [](const Standard_Real U, const Standard_Boolean PeriodicFlag, const Standard_Boolean HomogeneousFlag, Standard_Integer & ExtrapMode, const Standard_Integer Degree, const TColStd_Array1OfReal & FlatKnots, const TColgp_Array1OfPnt2d & Poles, const TColStd_Array1OfReal & Weights, gp_Pnt2d & Point, Standard_Real & Weight){ BSplCLib::Eval(U, PeriodicFlag, HomogeneousFlag, ExtrapMode, Degree, FlatKnots, Poles, Weights, Point, Weight); return std::tuple<Standard_Integer &, Standard_Real &>(ExtrapMode, Weight); }, "Perform the evaluation of the Bspline Basis and then multiplies by the weights this just evaluates the current point", py::arg("U"), py::arg("PeriodicFlag"), py::arg("HomogeneousFlag"), py::arg("ExtrapMode"), py::arg("Degree"), py::arg("FlatKnots"), py::arg("Poles"), py::arg("Weights"), py::arg("Point"), py::arg("Weight"));
	cls_BSplCLib.def_static("TangExtendToConstraint_", [](const TColStd_Array1OfReal & FlatKnots, const Standard_Real C1Coefficient, const Standard_Integer NumPoles, Standard_Real & Poles, const Standard_Integer Dimension, const Standard_Integer Degree, const TColStd_Array1OfReal & ConstraintPoint, const Standard_Integer Continuity, const Standard_Boolean After, Standard_Integer & NbPolesResult, Standard_Integer & NbKnotsRsult, Standard_Real & KnotsResult, Standard_Real & PolesResult){ BSplCLib::TangExtendToConstraint(FlatKnots, C1Coefficient, NumPoles, Poles, Dimension, Degree, ConstraintPoint, Continuity, After, NbPolesResult, NbKnotsRsult, KnotsResult, PolesResult); return std::tuple<Standard_Real &, Standard_Integer &, Standard_Integer &, Standard_Real &, Standard_Real &>(Poles, NbPolesResult, NbKnotsRsult, KnotsResult, PolesResult); }, "Extend a BSpline nD using the tangency map <C1Coefficient> is the coefficient of reparametrisation <Continuity> must be equal to 1, 2 or 3. <Degree> must be greater or equal than <Continuity> + 1.", py::arg("FlatKnots"), py::arg("C1Coefficient"), py::arg("NumPoles"), py::arg("Poles"), py::arg("Dimension"), py::arg("Degree"), py::arg("ConstraintPoint"), py::arg("Continuity"), py::arg("After"), py::arg("NbPolesResult"), py::arg("NbKnotsRsult"), py::arg("KnotsResult"), py::arg("PolesResult"));
	cls_BSplCLib.def_static("CacheD0_", (void (*)(const Standard_Real, const Standard_Integer, const Standard_Real, const Standard_Real, const TColgp_Array1OfPnt &, const TColStd_Array1OfReal *, gp_Pnt &)) &BSplCLib::CacheD0, "Perform the evaluation of the of the cache the parameter must be normalized between the 0 and 1 for the span. The Cache must be valid when calling this routine. Geom Package will insure that. and then multiplies by the weights this just evaluates the current point the CacheParameter is where the Cache was constructed the SpanLength is to normalize the polynomial in the cache to avoid bad conditioning effects", py::arg("U"), py::arg("Degree"), py::arg("CacheParameter"), py::arg("SpanLenght"), py::arg("Poles"), py::arg("Weights"), py::arg("Point"));
	cls_BSplCLib.def_static("CacheD0_", (void (*)(const Standard_Real, const Standard_Integer, const Standard_Real, const Standard_Real, const TColgp_Array1OfPnt2d &, const TColStd_Array1OfReal *, gp_Pnt2d &)) &BSplCLib::CacheD0, "Perform the evaluation of the Bspline Basis and then multiplies by the weights this just evaluates the current point the parameter must be normalized between the 0 and 1 for the span. The Cache must be valid when calling this routine. Geom Package will insure that. and then multiplies by the weights ththe CacheParameter is where the Cache was constructed the SpanLength is to normalize the polynomial in the cache to avoid bad conditioning effectsis just evaluates the current point", py::arg("U"), py::arg("Degree"), py::arg("CacheParameter"), py::arg("SpanLenght"), py::arg("Poles"), py::arg("Weights"), py::arg("Point"));
	cls_BSplCLib.def_static("CoefsD0_", (void (*)(const Standard_Real, const TColgp_Array1OfPnt &, const TColStd_Array1OfReal *, gp_Pnt &)) &BSplCLib::CoefsD0, "Calls CacheD0 for Bezier Curves Arrays computed with the method PolesCoefficients. Warning: To be used for Beziercurves ONLY!!!", py::arg("U"), py::arg("Poles"), py::arg("Weights"), py::arg("Point"));
	cls_BSplCLib.def_static("CoefsD0_", (void (*)(const Standard_Real, const TColgp_Array1OfPnt2d &, const TColStd_Array1OfReal *, gp_Pnt2d &)) &BSplCLib::CoefsD0, "Calls CacheD0 for Bezier Curves Arrays computed with the method PolesCoefficients. Warning: To be used for Beziercurves ONLY!!!", py::arg("U"), py::arg("Poles"), py::arg("Weights"), py::arg("Point"));
	cls_BSplCLib.def_static("CacheD1_", (void (*)(const Standard_Real, const Standard_Integer, const Standard_Real, const Standard_Real, const TColgp_Array1OfPnt &, const TColStd_Array1OfReal *, gp_Pnt &, gp_Vec &)) &BSplCLib::CacheD1, "Perform the evaluation of the of the cache the parameter must be normalized between the 0 and 1 for the span. The Cache must be valid when calling this routine. Geom Package will insure that. and then multiplies by the weights this just evaluates the current point the CacheParameter is where the Cache was constructed the SpanLength is to normalize the polynomial in the cache to avoid bad conditioning effects", py::arg("U"), py::arg("Degree"), py::arg("CacheParameter"), py::arg("SpanLenght"), py::arg("Poles"), py::arg("Weights"), py::arg("Point"), py::arg("Vec"));
	cls_BSplCLib.def_static("CacheD1_", (void (*)(const Standard_Real, const Standard_Integer, const Standard_Real, const Standard_Real, const TColgp_Array1OfPnt2d &, const TColStd_Array1OfReal *, gp_Pnt2d &, gp_Vec2d &)) &BSplCLib::CacheD1, "Perform the evaluation of the Bspline Basis and then multiplies by the weights this just evaluates the current point the parameter must be normalized between the 0 and 1 for the span. The Cache must be valid when calling this routine. Geom Package will insure that. and then multiplies by the weights ththe CacheParameter is where the Cache was constructed the SpanLength is to normalize the polynomial in the cache to avoid bad conditioning effectsis just evaluates the current point", py::arg("U"), py::arg("Degree"), py::arg("CacheParameter"), py::arg("SpanLenght"), py::arg("Poles"), py::arg("Weights"), py::arg("Point"), py::arg("Vec"));
	cls_BSplCLib.def_static("CoefsD1_", (void (*)(const Standard_Real, const TColgp_Array1OfPnt &, const TColStd_Array1OfReal *, gp_Pnt &, gp_Vec &)) &BSplCLib::CoefsD1, "Calls CacheD1 for Bezier Curves Arrays computed with the method PolesCoefficients. Warning: To be used for Beziercurves ONLY!!!", py::arg("U"), py::arg("Poles"), py::arg("Weights"), py::arg("Point"), py::arg("Vec"));
	cls_BSplCLib.def_static("CoefsD1_", (void (*)(const Standard_Real, const TColgp_Array1OfPnt2d &, const TColStd_Array1OfReal *, gp_Pnt2d &, gp_Vec2d &)) &BSplCLib::CoefsD1, "Calls CacheD1 for Bezier Curves Arrays computed with the method PolesCoefficients. Warning: To be used for Beziercurves ONLY!!!", py::arg("U"), py::arg("Poles"), py::arg("Weights"), py::arg("Point"), py::arg("Vec"));
	cls_BSplCLib.def_static("CacheD2_", (void (*)(const Standard_Real, const Standard_Integer, const Standard_Real, const Standard_Real, const TColgp_Array1OfPnt &, const TColStd_Array1OfReal *, gp_Pnt &, gp_Vec &, gp_Vec &)) &BSplCLib::CacheD2, "Perform the evaluation of the of the cache the parameter must be normalized between the 0 and 1 for the span. The Cache must be valid when calling this routine. Geom Package will insure that. and then multiplies by the weights this just evaluates the current point the CacheParameter is where the Cache was constructed the SpanLength is to normalize the polynomial in the cache to avoid bad conditioning effects", py::arg("U"), py::arg("Degree"), py::arg("CacheParameter"), py::arg("SpanLenght"), py::arg("Poles"), py::arg("Weights"), py::arg("Point"), py::arg("Vec1"), py::arg("Vec2"));
	cls_BSplCLib.def_static("CacheD2_", (void (*)(const Standard_Real, const Standard_Integer, const Standard_Real, const Standard_Real, const TColgp_Array1OfPnt2d &, const TColStd_Array1OfReal *, gp_Pnt2d &, gp_Vec2d &, gp_Vec2d &)) &BSplCLib::CacheD2, "Perform the evaluation of the Bspline Basis and then multiplies by the weights this just evaluates the current point the parameter must be normalized between the 0 and 1 for the span. The Cache must be valid when calling this routine. Geom Package will insure that. and then multiplies by the weights ththe CacheParameter is where the Cache was constructed the SpanLength is to normalize the polynomial in the cache to avoid bad conditioning effectsis just evaluates the current point", py::arg("U"), py::arg("Degree"), py::arg("CacheParameter"), py::arg("SpanLenght"), py::arg("Poles"), py::arg("Weights"), py::arg("Point"), py::arg("Vec1"), py::arg("Vec2"));
	cls_BSplCLib.def_static("CoefsD2_", (void (*)(const Standard_Real, const TColgp_Array1OfPnt &, const TColStd_Array1OfReal *, gp_Pnt &, gp_Vec &, gp_Vec &)) &BSplCLib::CoefsD2, "Calls CacheD1 for Bezier Curves Arrays computed with the method PolesCoefficients. Warning: To be used for Beziercurves ONLY!!!", py::arg("U"), py::arg("Poles"), py::arg("Weights"), py::arg("Point"), py::arg("Vec1"), py::arg("Vec2"));
	cls_BSplCLib.def_static("CoefsD2_", (void (*)(const Standard_Real, const TColgp_Array1OfPnt2d &, const TColStd_Array1OfReal *, gp_Pnt2d &, gp_Vec2d &, gp_Vec2d &)) &BSplCLib::CoefsD2, "Calls CacheD1 for Bezier Curves Arrays computed with the method PolesCoefficients. Warning: To be used for Beziercurves ONLY!!!", py::arg("U"), py::arg("Poles"), py::arg("Weights"), py::arg("Point"), py::arg("Vec1"), py::arg("Vec2"));
	cls_BSplCLib.def_static("CacheD3_", (void (*)(const Standard_Real, const Standard_Integer, const Standard_Real, const Standard_Real, const TColgp_Array1OfPnt &, const TColStd_Array1OfReal *, gp_Pnt &, gp_Vec &, gp_Vec &, gp_Vec &)) &BSplCLib::CacheD3, "Perform the evaluation of the of the cache the parameter must be normalized between the 0 and 1 for the span. The Cache must be valid when calling this routine. Geom Package will insure that. and then multiplies by the weights this just evaluates the current point the CacheParameter is where the Cache was constructed the SpanLength is to normalize the polynomial in the cache to avoid bad conditioning effects", py::arg("U"), py::arg("Degree"), py::arg("CacheParameter"), py::arg("SpanLenght"), py::arg("Poles"), py::arg("Weights"), py::arg("Point"), py::arg("Vec1"), py::arg("Vec2"), py::arg("Vec3"));
	cls_BSplCLib.def_static("CacheD3_", (void (*)(const Standard_Real, const Standard_Integer, const Standard_Real, const Standard_Real, const TColgp_Array1OfPnt2d &, const TColStd_Array1OfReal *, gp_Pnt2d &, gp_Vec2d &, gp_Vec2d &, gp_Vec2d &)) &BSplCLib::CacheD3, "Perform the evaluation of the Bspline Basis and then multiplies by the weights this just evaluates the current point the parameter must be normalized between the 0 and 1 for the span. The Cache must be valid when calling this routine. Geom Package will insure that. and then multiplies by the weights ththe CacheParameter is where the Cache was constructed the SpanLength is to normalize the polynomial in the cache to avoid bad conditioning effectsis just evaluates the current point", py::arg("U"), py::arg("Degree"), py::arg("CacheParameter"), py::arg("SpanLenght"), py::arg("Poles"), py::arg("Weights"), py::arg("Point"), py::arg("Vec1"), py::arg("Vec2"), py::arg("Vec3"));
	cls_BSplCLib.def_static("CoefsD3_", (void (*)(const Standard_Real, const TColgp_Array1OfPnt &, const TColStd_Array1OfReal *, gp_Pnt &, gp_Vec &, gp_Vec &, gp_Vec &)) &BSplCLib::CoefsD3, "Calls CacheD1 for Bezier Curves Arrays computed with the method PolesCoefficients. Warning: To be used for Beziercurves ONLY!!!", py::arg("U"), py::arg("Poles"), py::arg("Weights"), py::arg("Point"), py::arg("Vec1"), py::arg("Vec2"), py::arg("Vec3"));
	cls_BSplCLib.def_static("CoefsD3_", (void (*)(const Standard_Real, const TColgp_Array1OfPnt2d &, const TColStd_Array1OfReal *, gp_Pnt2d &, gp_Vec2d &, gp_Vec2d &, gp_Vec2d &)) &BSplCLib::CoefsD3, "Calls CacheD1 for Bezier Curves Arrays computed with the method PolesCoefficients. Warning: To be used for Beziercurves ONLY!!!", py::arg("U"), py::arg("Poles"), py::arg("Weights"), py::arg("Point"), py::arg("Vec1"), py::arg("Vec2"), py::arg("Vec3"));
	cls_BSplCLib.def_static("BuildCache_", (void (*)(const Standard_Real, const Standard_Real, const Standard_Boolean, const Standard_Integer, const TColStd_Array1OfReal &, const TColgp_Array1OfPnt &, const TColStd_Array1OfReal *, TColgp_Array1OfPnt &, TColStd_Array1OfReal *)) &BSplCLib::BuildCache, "Perform the evaluation of the Taylor expansion of the Bspline normalized between 0 and 1. If rational computes the homogeneous Taylor expension for the numerator and stores it in CachePoles", py::arg("U"), py::arg("InverseOfSpanDomain"), py::arg("PeriodicFlag"), py::arg("Degree"), py::arg("FlatKnots"), py::arg("Poles"), py::arg("Weights"), py::arg("CachePoles"), py::arg("CacheWeights"));
	cls_BSplCLib.def_static("BuildCache_", (void (*)(const Standard_Real, const Standard_Real, const Standard_Boolean, const Standard_Integer, const TColStd_Array1OfReal &, const TColgp_Array1OfPnt2d &, const TColStd_Array1OfReal *, TColgp_Array1OfPnt2d &, TColStd_Array1OfReal *)) &BSplCLib::BuildCache, "Perform the evaluation of the Taylor expansion of the Bspline normalized between 0 and 1. If rational computes the homogeneous Taylor expension for the numerator and stores it in CachePoles", py::arg("U"), py::arg("InverseOfSpanDomain"), py::arg("PeriodicFlag"), py::arg("Degree"), py::arg("FlatKnots"), py::arg("Poles"), py::arg("Weights"), py::arg("CachePoles"), py::arg("CacheWeights"));
	cls_BSplCLib.def_static("BuildCache_", (void (*)(const Standard_Real, const Standard_Real, const Standard_Boolean, const Standard_Integer, const Standard_Integer, const TColStd_Array1OfReal &, const TColgp_Array1OfPnt &, const TColStd_Array1OfReal *, TColStd_Array2OfReal &)) &BSplCLib::BuildCache, "Perform the evaluation of the Taylor expansion of the Bspline normalized between 0 and 1. Structure of result optimized for BSplCLib_Cache.", py::arg("theParameter"), py::arg("theSpanDomain"), py::arg("thePeriodicFlag"), py::arg("theDegree"), py::arg("theSpanIndex"), py::arg("theFlatKnots"), py::arg("thePoles"), py::arg("theWeights"), py::arg("theCacheArray"));
	cls_BSplCLib.def_static("BuildCache_", (void (*)(const Standard_Real, const Standard_Real, const Standard_Boolean, const Standard_Integer, const Standard_Integer, const TColStd_Array1OfReal &, const TColgp_Array1OfPnt2d &, const TColStd_Array1OfReal *, TColStd_Array2OfReal &)) &BSplCLib::BuildCache, "Perform the evaluation of the Taylor expansion of the Bspline normalized between 0 and 1. Structure of result optimized for BSplCLib_Cache.", py::arg("theParameter"), py::arg("theSpanDomain"), py::arg("thePeriodicFlag"), py::arg("theDegree"), py::arg("theSpanIndex"), py::arg("theFlatKnots"), py::arg("thePoles"), py::arg("theWeights"), py::arg("theCacheArray"));
	cls_BSplCLib.def_static("PolesCoefficients_", (void (*)(const TColgp_Array1OfPnt2d &, TColgp_Array1OfPnt2d &)) &BSplCLib::PolesCoefficients, "None", py::arg("Poles"), py::arg("CachePoles"));
	cls_BSplCLib.def_static("PolesCoefficients_", (void (*)(const TColgp_Array1OfPnt2d &, const TColStd_Array1OfReal *, TColgp_Array1OfPnt2d &, TColStd_Array1OfReal *)) &BSplCLib::PolesCoefficients, "None", py::arg("Poles"), py::arg("Weights"), py::arg("CachePoles"), py::arg("CacheWeights"));
	cls_BSplCLib.def_static("PolesCoefficients_", (void (*)(const TColgp_Array1OfPnt &, TColgp_Array1OfPnt &)) &BSplCLib::PolesCoefficients, "None", py::arg("Poles"), py::arg("CachePoles"));
	cls_BSplCLib.def_static("PolesCoefficients_", (void (*)(const TColgp_Array1OfPnt &, const TColStd_Array1OfReal *, TColgp_Array1OfPnt &, TColStd_Array1OfReal *)) &BSplCLib::PolesCoefficients, "Encapsulation of BuildCache to perform the evaluation of the Taylor expansion for beziercurves at parameter 0. Warning: To be used for Beziercurves ONLY!!!", py::arg("Poles"), py::arg("Weights"), py::arg("CachePoles"), py::arg("CacheWeights"));
	cls_BSplCLib.def_static("FlatBezierKnots_", (const Standard_Real & (*)(const Standard_Integer)) &BSplCLib::FlatBezierKnots, "Returns pointer to statically allocated array representing flat knots for bezier curve of the specified degree. Raises OutOfRange if Degree > MaxDegree()", py::arg("Degree"));
	cls_BSplCLib.def_static("BuildSchoenbergPoints_", (void (*)(const Standard_Integer, const TColStd_Array1OfReal &, TColStd_Array1OfReal &)) &BSplCLib::BuildSchoenbergPoints, "builds the Schoenberg points from the flat knot used to interpolate a BSpline since the BSpline matrix is invertible.", py::arg("Degree"), py::arg("FlatKnots"), py::arg("Parameters"));
	cls_BSplCLib.def_static("Interpolate_", [](const Standard_Integer Degree, const TColStd_Array1OfReal & FlatKnots, const TColStd_Array1OfReal & Parameters, const TColStd_Array1OfInteger & ContactOrderArray, TColgp_Array1OfPnt & Poles, Standard_Integer & InversionProblem){ BSplCLib::Interpolate(Degree, FlatKnots, Parameters, ContactOrderArray, Poles, InversionProblem); return InversionProblem; }, "Performs the interpolation of the data given in the Poles array according to the requests in ContactOrderArray that is : if ContactOrderArray(i) has value d it means that Poles(i) containes the dth derivative of the function to be interpolated. The length L of the following arrays must be the same : Parameters, ContactOrderArray, Poles, The length of FlatKnots is Degree + L + 1 Warning: the method used to do that interpolation is gauss elimination WITHOUT pivoting. Thus if the diagonal is not dominant there is no guarantee that the algorithm will work. Nevertheless for Cubic interpolation or interpolation at Scheonberg points the method will work The InversionProblem will report 0 if there was no problem else it will give the index of the faulty pivot", py::arg("Degree"), py::arg("FlatKnots"), py::arg("Parameters"), py::arg("ContactOrderArray"), py::arg("Poles"), py::arg("InversionProblem"));
	cls_BSplCLib.def_static("Interpolate_", [](const Standard_Integer Degree, const TColStd_Array1OfReal & FlatKnots, const TColStd_Array1OfReal & Parameters, const TColStd_Array1OfInteger & ContactOrderArray, TColgp_Array1OfPnt2d & Poles, Standard_Integer & InversionProblem){ BSplCLib::Interpolate(Degree, FlatKnots, Parameters, ContactOrderArray, Poles, InversionProblem); return InversionProblem; }, "Performs the interpolation of the data given in the Poles array according to the requests in ContactOrderArray that is : if ContactOrderArray(i) has value d it means that Poles(i) containes the dth derivative of the function to be interpolated. The length L of the following arrays must be the same : Parameters, ContactOrderArray, Poles, The length of FlatKnots is Degree + L + 1 Warning: the method used to do that interpolation is gauss elimination WITHOUT pivoting. Thus if the diagonal is not dominant there is no guarantee that the algorithm will work. Nevertheless for Cubic interpolation at knots or interpolation at Scheonberg points the method will work. The InversionProblem w ll report 0 if there was no problem else it will give the index of the faulty pivot", py::arg("Degree"), py::arg("FlatKnots"), py::arg("Parameters"), py::arg("ContactOrderArray"), py::arg("Poles"), py::arg("InversionProblem"));
	cls_BSplCLib.def_static("Interpolate_", [](const Standard_Integer Degree, const TColStd_Array1OfReal & FlatKnots, const TColStd_Array1OfReal & Parameters, const TColStd_Array1OfInteger & ContactOrderArray, TColgp_Array1OfPnt & Poles, TColStd_Array1OfReal & Weights, Standard_Integer & InversionProblem){ BSplCLib::Interpolate(Degree, FlatKnots, Parameters, ContactOrderArray, Poles, Weights, InversionProblem); return InversionProblem; }, "Performs the interpolation of the data given in the Poles array according to the requests in ContactOrderArray that is : if ContactOrderArray(i) has value d it means that Poles(i) containes the dth derivative of the function to be interpolated. The length L of the following arrays must be the same : Parameters, ContactOrderArray, Poles, The length of FlatKnots is Degree + L + 1 Warning: the method used to do that interpolation is gauss elimination WITHOUT pivoting. Thus if the diagonal is not dominant there is no guarantee that the algorithm will work. Nevertheless for Cubic interpolation at knots or interpolation at Scheonberg points the method will work. The InversionProblem will report 0 if there was no problem else it will give the index of the faulty pivot", py::arg("Degree"), py::arg("FlatKnots"), py::arg("Parameters"), py::arg("ContactOrderArray"), py::arg("Poles"), py::arg("Weights"), py::arg("InversionProblem"));
	cls_BSplCLib.def_static("Interpolate_", [](const Standard_Integer Degree, const TColStd_Array1OfReal & FlatKnots, const TColStd_Array1OfReal & Parameters, const TColStd_Array1OfInteger & ContactOrderArray, TColgp_Array1OfPnt2d & Poles, TColStd_Array1OfReal & Weights, Standard_Integer & InversionProblem){ BSplCLib::Interpolate(Degree, FlatKnots, Parameters, ContactOrderArray, Poles, Weights, InversionProblem); return InversionProblem; }, "Performs the interpolation of the data given in the Poles array according to the requests in ContactOrderArray that is : if ContactOrderArray(i) has value d it means that Poles(i) containes the dth derivative of the function to be interpolated. The length L of the following arrays must be the same : Parameters, ContactOrderArray, Poles, The length of FlatKnots is Degree + L + 1 Warning: the method used to do that interpolation is gauss elimination WITHOUT pivoting. Thus if the diagonal is not dominant there is no guarantee that the algorithm will work. Nevertheless for Cubic interpolation at knots or interpolation at Scheonberg points the method will work. The InversionProblem w ll report 0 if there was no problem else it will give the i", py::arg("Degree"), py::arg("FlatKnots"), py::arg("Parameters"), py::arg("ContactOrderArray"), py::arg("Poles"), py::arg("Weights"), py::arg("InversionProblem"));
	cls_BSplCLib.def_static("Interpolate_", [](const Standard_Integer Degree, const TColStd_Array1OfReal & FlatKnots, const TColStd_Array1OfReal & Parameters, const TColStd_Array1OfInteger & ContactOrderArray, const Standard_Integer ArrayDimension, Standard_Real & Poles, Standard_Integer & InversionProblem){ BSplCLib::Interpolate(Degree, FlatKnots, Parameters, ContactOrderArray, ArrayDimension, Poles, InversionProblem); return std::tuple<Standard_Real &, Standard_Integer &>(Poles, InversionProblem); }, "Performs the interpolation of the data given in the Poles array according to the requests in ContactOrderArray that is : if ContactOrderArray(i) has value d it means that Poles(i) containes the dth derivative of the function to be interpolated. The length L of the following arrays must be the same : Parameters, ContactOrderArray The length of FlatKnots is Degree + L + 1 The PolesArray is an seen as an Array[1..N][1..ArrayDimension] with N = tge length of the parameters array Warning: the method used to do that interpolation is gauss elimination WITHOUT pivoting. Thus if the diagonal is not dominant there is no guarantee that the algorithm will work. Nevertheless for Cubic interpolation or interpolation at Scheonberg points the method will work The InversionProblem will report 0 if there was no problem else it will give the index of the faulty pivot", py::arg("Degree"), py::arg("FlatKnots"), py::arg("Parameters"), py::arg("ContactOrderArray"), py::arg("ArrayDimension"), py::arg("Poles"), py::arg("InversionProblem"));
	cls_BSplCLib.def_static("Interpolate_", [](const Standard_Integer Degree, const TColStd_Array1OfReal & FlatKnots, const TColStd_Array1OfReal & Parameters, const TColStd_Array1OfInteger & ContactOrderArray, const Standard_Integer ArrayDimension, Standard_Real & Poles, Standard_Real & Weights, Standard_Integer & InversionProblem){ BSplCLib::Interpolate(Degree, FlatKnots, Parameters, ContactOrderArray, ArrayDimension, Poles, Weights, InversionProblem); return std::tuple<Standard_Real &, Standard_Real &, Standard_Integer &>(Poles, Weights, InversionProblem); }, "None", py::arg("Degree"), py::arg("FlatKnots"), py::arg("Parameters"), py::arg("ContactOrderArray"), py::arg("ArrayDimension"), py::arg("Poles"), py::arg("Weights"), py::arg("InversionProblem"));
	cls_BSplCLib.def_static("MovePoint_", [](const Standard_Real U, const gp_Vec2d & Displ, const Standard_Integer Index1, const Standard_Integer Index2, const Standard_Integer Degree, const Standard_Boolean Rational, const TColgp_Array1OfPnt2d & Poles, const TColStd_Array1OfReal & Weights, const TColStd_Array1OfReal & FlatKnots, Standard_Integer & FirstIndex, Standard_Integer & LastIndex, TColgp_Array1OfPnt2d & NewPoles){ BSplCLib::MovePoint(U, Displ, Index1, Index2, Degree, Rational, Poles, Weights, FlatKnots, FirstIndex, LastIndex, NewPoles); return std::tuple<Standard_Integer &, Standard_Integer &>(FirstIndex, LastIndex); }, "Find the new poles which allows an old point (with a given u as parameter) to reach a new position Index1 and Index2 indicate the range of poles we can move (1, NbPoles-1) or (2, NbPoles) -> no constraint for one side don't enter (1,NbPoles) -> error: rigid move (2, NbPoles-1) -> the ends are enforced (3, NbPoles-2) -> the ends and the tangency are enforced if Problem in BSplineBasis calculation, no change for the curve and FirstIndex, LastIndex = 0", py::arg("U"), py::arg("Displ"), py::arg("Index1"), py::arg("Index2"), py::arg("Degree"), py::arg("Rational"), py::arg("Poles"), py::arg("Weights"), py::arg("FlatKnots"), py::arg("FirstIndex"), py::arg("LastIndex"), py::arg("NewPoles"));
	cls_BSplCLib.def_static("MovePoint_", [](const Standard_Real U, const gp_Vec & Displ, const Standard_Integer Index1, const Standard_Integer Index2, const Standard_Integer Degree, const Standard_Boolean Rational, const TColgp_Array1OfPnt & Poles, const TColStd_Array1OfReal & Weights, const TColStd_Array1OfReal & FlatKnots, Standard_Integer & FirstIndex, Standard_Integer & LastIndex, TColgp_Array1OfPnt & NewPoles){ BSplCLib::MovePoint(U, Displ, Index1, Index2, Degree, Rational, Poles, Weights, FlatKnots, FirstIndex, LastIndex, NewPoles); return std::tuple<Standard_Integer &, Standard_Integer &>(FirstIndex, LastIndex); }, "Find the new poles which allows an old point (with a given u as parameter) to reach a new position Index1 and Index2 indicate the range of poles we can move (1, NbPoles-1) or (2, NbPoles) -> no constraint for one side don't enter (1,NbPoles) -> error: rigid move (2, NbPoles-1) -> the ends are enforced (3, NbPoles-2) -> the ends and the tangency are enforced if Problem in BSplineBasis calculation, no change for the curve and FirstIndex, LastIndex = 0", py::arg("U"), py::arg("Displ"), py::arg("Index1"), py::arg("Index2"), py::arg("Degree"), py::arg("Rational"), py::arg("Poles"), py::arg("Weights"), py::arg("FlatKnots"), py::arg("FirstIndex"), py::arg("LastIndex"), py::arg("NewPoles"));
	cls_BSplCLib.def_static("MovePointAndTangent_", [](const Standard_Real U, const Standard_Integer ArrayDimension, Standard_Real & Delta, Standard_Real & DeltaDerivative, const Standard_Real Tolerance, const Standard_Integer Degree, const Standard_Boolean Rational, const Standard_Integer StartingCondition, const Standard_Integer EndingCondition, Standard_Real & Poles, const TColStd_Array1OfReal & Weights, const TColStd_Array1OfReal & FlatKnots, Standard_Real & NewPoles, Standard_Integer & ErrorStatus){ BSplCLib::MovePointAndTangent(U, ArrayDimension, Delta, DeltaDerivative, Tolerance, Degree, Rational, StartingCondition, EndingCondition, Poles, Weights, FlatKnots, NewPoles, ErrorStatus); return std::tuple<Standard_Real &, Standard_Real &, Standard_Real &, Standard_Real &, Standard_Integer &>(Delta, DeltaDerivative, Poles, NewPoles, ErrorStatus); }, "This is the dimension free version of the utility U is the parameter must be within the first FlatKnots and the last FlatKnots Delta is the amount the curve has to be moved DeltaDerivative is the amount the derivative has to be moved. Delta and DeltaDerivative must be array of dimension ArrayDimension Degree is the degree of the BSpline and the FlatKnots are the knots of the BSpline Starting Condition if = -1 means the starting point of the curve can move = 0 means the starting point of the cuve cannot move but tangen starting point of the curve cannot move = 1 means the starting point and tangents cannot move = 2 means the starting point tangent and curvature cannot move = ... Same holds for EndingCondition Poles are the poles of the curve Weights are the weights of the curve if Rational = Standard_True NewPoles are the poles of the deformed curve ErrorStatus will be 0 if no error happened 1 if there are not enough knots/poles the imposed conditions The way to solve this problem is to add knots to the BSpline If StartCondition = 1 and EndCondition = 1 then you need at least 4 + 2 = 6 poles so for example to have a C1 cubic you will need have at least 2 internal knots.", py::arg("U"), py::arg("ArrayDimension"), py::arg("Delta"), py::arg("DeltaDerivative"), py::arg("Tolerance"), py::arg("Degree"), py::arg("Rational"), py::arg("StartingCondition"), py::arg("EndingCondition"), py::arg("Poles"), py::arg("Weights"), py::arg("FlatKnots"), py::arg("NewPoles"), py::arg("ErrorStatus"));
	cls_BSplCLib.def_static("MovePointAndTangent_", [](const Standard_Real U, const gp_Vec & Delta, const gp_Vec & DeltaDerivative, const Standard_Real Tolerance, const Standard_Integer Degree, const Standard_Boolean Rational, const Standard_Integer StartingCondition, const Standard_Integer EndingCondition, const TColgp_Array1OfPnt & Poles, const TColStd_Array1OfReal & Weights, const TColStd_Array1OfReal & FlatKnots, TColgp_Array1OfPnt & NewPoles, Standard_Integer & ErrorStatus){ BSplCLib::MovePointAndTangent(U, Delta, DeltaDerivative, Tolerance, Degree, Rational, StartingCondition, EndingCondition, Poles, Weights, FlatKnots, NewPoles, ErrorStatus); return ErrorStatus; }, "This is the dimension free version of the utility U is the parameter must be within the first FlatKnots and the last FlatKnots Delta is the amount the curve has to be moved DeltaDerivative is the amount the derivative has to be moved. Delta and DeltaDerivative must be array of dimension ArrayDimension Degree is the degree of the BSpline and the FlatKnots are the knots of the BSpline Starting Condition if = -1 means the starting point of the curve can move = 0 means the starting point of the cuve cannot move but tangen starting point of the curve cannot move = 1 means the starting point and tangents cannot move = 2 means the starting point tangent and curvature cannot move = ... Same holds for EndingCondition Poles are the poles of the curve Weights are the weights of the curve if Rational = Standard_True NewPoles are the poles of the deformed curve ErrorStatus will be 0 if no error happened 1 if there are not enough knots/poles the imposed conditions The way to solve this problem is to add knots to the BSpline If StartCondition = 1 and EndCondition = 1 then you need at least 4 + 2 = 6 poles so for example to have a C1 cubic you will need have at least 2 internal knots.", py::arg("U"), py::arg("Delta"), py::arg("DeltaDerivative"), py::arg("Tolerance"), py::arg("Degree"), py::arg("Rational"), py::arg("StartingCondition"), py::arg("EndingCondition"), py::arg("Poles"), py::arg("Weights"), py::arg("FlatKnots"), py::arg("NewPoles"), py::arg("ErrorStatus"));
	cls_BSplCLib.def_static("MovePointAndTangent_", [](const Standard_Real U, const gp_Vec2d & Delta, const gp_Vec2d & DeltaDerivative, const Standard_Real Tolerance, const Standard_Integer Degree, const Standard_Boolean Rational, const Standard_Integer StartingCondition, const Standard_Integer EndingCondition, const TColgp_Array1OfPnt2d & Poles, const TColStd_Array1OfReal & Weights, const TColStd_Array1OfReal & FlatKnots, TColgp_Array1OfPnt2d & NewPoles, Standard_Integer & ErrorStatus){ BSplCLib::MovePointAndTangent(U, Delta, DeltaDerivative, Tolerance, Degree, Rational, StartingCondition, EndingCondition, Poles, Weights, FlatKnots, NewPoles, ErrorStatus); return ErrorStatus; }, "This is the dimension free version of the utility U is the parameter must be within the first FlatKnots and the last FlatKnots Delta is the amount the curve has to be moved DeltaDerivative is the amount the derivative has to be moved. Delta and DeltaDerivative must be array of dimension ArrayDimension Degree is the degree of the BSpline and the FlatKnots are the knots of the BSpline Starting Condition if = -1 means the starting point of the curve can move = 0 means the starting point of the cuve cannot move but tangen starting point of the curve cannot move = 1 means the starting point and tangents cannot move = 2 means the starting point tangent and curvature cannot move = ... Same holds for EndingCondition Poles are the poles of the curve Weights are the weights of the curve if Rational = Standard_True NewPoles are the poles of the deformed curve ErrorStatus will be 0 if no error happened 1 if there are not enough knots/poles the imposed conditions The way to solve this problem is to add knots to the BSpline If StartCondition = 1 and EndCondition = 1 then you need at least 4 + 2 = 6 poles so for example to have a C1 cubic you will need have at least 2 internal knots.", py::arg("U"), py::arg("Delta"), py::arg("DeltaDerivative"), py::arg("Tolerance"), py::arg("Degree"), py::arg("Rational"), py::arg("StartingCondition"), py::arg("EndingCondition"), py::arg("Poles"), py::arg("Weights"), py::arg("FlatKnots"), py::arg("NewPoles"), py::arg("ErrorStatus"));
	cls_BSplCLib.def_static("Resolution_", [](Standard_Real & PolesArray, const Standard_Integer ArrayDimension, const Standard_Integer NumPoles, const TColStd_Array1OfReal * Weights, const TColStd_Array1OfReal & FlatKnots, const Standard_Integer Degree, const Standard_Real Tolerance3D, Standard_Real & UTolerance){ BSplCLib::Resolution(PolesArray, ArrayDimension, NumPoles, Weights, FlatKnots, Degree, Tolerance3D, UTolerance); return std::tuple<Standard_Real &, Standard_Real &>(PolesArray, UTolerance); }, "given a tolerance in 3D space returns a tolerance in U parameter space such that all u1 and u0 in the domain of the curve f(u) | u1 - u0 | < UTolerance and we have |f (u1) - f (u0)| < Tolerance3D", py::arg("PolesArray"), py::arg("ArrayDimension"), py::arg("NumPoles"), py::arg("Weights"), py::arg("FlatKnots"), py::arg("Degree"), py::arg("Tolerance3D"), py::arg("UTolerance"));
	cls_BSplCLib.def_static("Resolution_", [](const TColgp_Array1OfPnt & Poles, const TColStd_Array1OfReal * Weights, const Standard_Integer NumPoles, const TColStd_Array1OfReal & FlatKnots, const Standard_Integer Degree, const Standard_Real Tolerance3D, Standard_Real & UTolerance){ BSplCLib::Resolution(Poles, Weights, NumPoles, FlatKnots, Degree, Tolerance3D, UTolerance); return UTolerance; }, "given a tolerance in 3D space returns a tolerance in U parameter space such that all u1 and u0 in the domain of the curve f(u) | u1 - u0 | < UTolerance and we have |f (u1) - f (u0)| < Tolerance3D", py::arg("Poles"), py::arg("Weights"), py::arg("NumPoles"), py::arg("FlatKnots"), py::arg("Degree"), py::arg("Tolerance3D"), py::arg("UTolerance"));
	cls_BSplCLib.def_static("Resolution_", [](const TColgp_Array1OfPnt2d & Poles, const TColStd_Array1OfReal * Weights, const Standard_Integer NumPoles, const TColStd_Array1OfReal & FlatKnots, const Standard_Integer Degree, const Standard_Real Tolerance3D, Standard_Real & UTolerance){ BSplCLib::Resolution(Poles, Weights, NumPoles, FlatKnots, Degree, Tolerance3D, UTolerance); return UTolerance; }, "given a tolerance in 3D space returns a tolerance in U parameter space such that all u1 and u0 in the domain of the curve f(u) | u1 - u0 | < UTolerance and we have |f (u1) - f (u0)| < Tolerance3D", py::arg("Poles"), py::arg("Weights"), py::arg("NumPoles"), py::arg("FlatKnots"), py::arg("Degree"), py::arg("Tolerance3D"), py::arg("UTolerance"));

	// C:\Miniconda\envs\occt\Library\include\opencascade\BSplCLib_Cache.hxx
	py::class_<BSplCLib_Cache, opencascade::handle<BSplCLib_Cache>, Standard_Transient> cls_BSplCLib_Cache(mod, "BSplCLib_Cache", "A cache class for Bezier and B-spline curves.");
	cls_BSplCLib_Cache.def(py::init<>());
	cls_BSplCLib_Cache.def(py::init<const Standard_Integer &, const Standard_Boolean &, const TColStd_Array1OfReal &, const TColgp_Array1OfPnt2d &>(), py::arg("theDegree"), py::arg("thePeriodic"), py::arg("theFlatKnots"), py::arg("thePoles2d"));
	cls_BSplCLib_Cache.def(py::init<const Standard_Integer &, const Standard_Boolean &, const TColStd_Array1OfReal &, const TColgp_Array1OfPnt2d &, const TColStd_Array1OfReal *>(), py::arg("theDegree"), py::arg("thePeriodic"), py::arg("theFlatKnots"), py::arg("thePoles2d"), py::arg("theWeights"));
	cls_BSplCLib_Cache.def(py::init<const Standard_Integer &, const Standard_Boolean &, const TColStd_Array1OfReal &, const TColgp_Array1OfPnt &>(), py::arg("theDegree"), py::arg("thePeriodic"), py::arg("theFlatKnots"), py::arg("thePoles"));
	cls_BSplCLib_Cache.def(py::init<const Standard_Integer &, const Standard_Boolean &, const TColStd_Array1OfReal &, const TColgp_Array1OfPnt &, const TColStd_Array1OfReal *>(), py::arg("theDegree"), py::arg("thePeriodic"), py::arg("theFlatKnots"), py::arg("thePoles"), py::arg("theWeights"));
	cls_BSplCLib_Cache.def("IsCacheValid", (Standard_Boolean (BSplCLib_Cache::*)(Standard_Real) const ) &BSplCLib_Cache::IsCacheValid, "Verifies validity of the cache using flat parameter of the point", py::arg("theParameter"));
	cls_BSplCLib_Cache.def("BuildCache", [](BSplCLib_Cache &self, const Standard_Real & a0, const Standard_Integer & a1, const Standard_Boolean & a2, const TColStd_Array1OfReal & a3, const TColgp_Array1OfPnt2d & a4) -> void { return self.BuildCache(a0, a1, a2, a3, a4); }, py::arg("theParameter"), py::arg("theDegree"), py::arg("thePeriodic"), py::arg("theFlatKnots"), py::arg("thePoles2d"));
	cls_BSplCLib_Cache.def("BuildCache", (void (BSplCLib_Cache::*)(const Standard_Real &, const Standard_Integer &, const Standard_Boolean &, const TColStd_Array1OfReal &, const TColgp_Array1OfPnt2d &, const TColStd_Array1OfReal *)) &BSplCLib_Cache::BuildCache, "Recomputes the cache data for 2D curves. Does not verify validity of the cache", py::arg("theParameter"), py::arg("theDegree"), py::arg("thePeriodic"), py::arg("theFlatKnots"), py::arg("thePoles2d"), py::arg("theWeights"));
	cls_BSplCLib_Cache.def("BuildCache", [](BSplCLib_Cache &self, const Standard_Real & a0, const Standard_Integer & a1, const Standard_Boolean & a2, const TColStd_Array1OfReal & a3, const TColgp_Array1OfPnt & a4) -> void { return self.BuildCache(a0, a1, a2, a3, a4); }, py::arg("theParameter"), py::arg("theDegree"), py::arg("thePeriodic"), py::arg("theFlatKnots"), py::arg("thePoles"));
	cls_BSplCLib_Cache.def("BuildCache", (void (BSplCLib_Cache::*)(const Standard_Real &, const Standard_Integer &, const Standard_Boolean &, const TColStd_Array1OfReal &, const TColgp_Array1OfPnt &, const TColStd_Array1OfReal *)) &BSplCLib_Cache::BuildCache, "Recomputes the cache data for 3D curves. Does not verify validity of the cache", py::arg("theParameter"), py::arg("theDegree"), py::arg("thePeriodic"), py::arg("theFlatKnots"), py::arg("thePoles"), py::arg("theWeights"));
	cls_BSplCLib_Cache.def("D0", (void (BSplCLib_Cache::*)(const Standard_Real &, gp_Pnt2d &) const ) &BSplCLib_Cache::D0, "Calculates the point on the curve in the specified parameter", py::arg("theParameter"), py::arg("thePoint"));
	cls_BSplCLib_Cache.def("D0", (void (BSplCLib_Cache::*)(const Standard_Real &, gp_Pnt &) const ) &BSplCLib_Cache::D0, "None", py::arg("theParameter"), py::arg("thePoint"));
	cls_BSplCLib_Cache.def("D1", (void (BSplCLib_Cache::*)(const Standard_Real &, gp_Pnt2d &, gp_Vec2d &) const ) &BSplCLib_Cache::D1, "Calculates the point on the curve and its first derivative in the specified parameter", py::arg("theParameter"), py::arg("thePoint"), py::arg("theTangent"));
	cls_BSplCLib_Cache.def("D1", (void (BSplCLib_Cache::*)(const Standard_Real &, gp_Pnt &, gp_Vec &) const ) &BSplCLib_Cache::D1, "None", py::arg("theParameter"), py::arg("thePoint"), py::arg("theTangent"));
	cls_BSplCLib_Cache.def("D2", (void (BSplCLib_Cache::*)(const Standard_Real &, gp_Pnt2d &, gp_Vec2d &, gp_Vec2d &) const ) &BSplCLib_Cache::D2, "Calculates the point on the curve and two derivatives in the specified parameter", py::arg("theParameter"), py::arg("thePoint"), py::arg("theTangent"), py::arg("theCurvature"));
	cls_BSplCLib_Cache.def("D2", (void (BSplCLib_Cache::*)(const Standard_Real &, gp_Pnt &, gp_Vec &, gp_Vec &) const ) &BSplCLib_Cache::D2, "None", py::arg("theParameter"), py::arg("thePoint"), py::arg("theTangent"), py::arg("theCurvature"));
	cls_BSplCLib_Cache.def("D3", (void (BSplCLib_Cache::*)(const Standard_Real &, gp_Pnt2d &, gp_Vec2d &, gp_Vec2d &, gp_Vec2d &) const ) &BSplCLib_Cache::D3, "Calculates the point on the curve and three derivatives in the specified parameter", py::arg("theParameter"), py::arg("thePoint"), py::arg("theTangent"), py::arg("theCurvature"), py::arg("theTorsion"));
	cls_BSplCLib_Cache.def("D3", (void (BSplCLib_Cache::*)(const Standard_Real &, gp_Pnt &, gp_Vec &, gp_Vec &, gp_Vec &) const ) &BSplCLib_Cache::D3, "None", py::arg("theParameter"), py::arg("thePoint"), py::arg("theTangent"), py::arg("theCurvature"), py::arg("theTorsion"));
	cls_BSplCLib_Cache.def_static("get_type_name_", (const char * (*)()) &BSplCLib_Cache::get_type_name, "None");
	cls_BSplCLib_Cache.def_static("get_type_descriptor_", (const opencascade::handle<Standard_Type> & (*)()) &BSplCLib_Cache::get_type_descriptor, "None");
	cls_BSplCLib_Cache.def("DynamicType", (const opencascade::handle<Standard_Type> & (BSplCLib_Cache::*)() const ) &BSplCLib_Cache::DynamicType, "None");


}
