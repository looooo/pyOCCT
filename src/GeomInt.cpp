/*
This file is part of pyOCCT which provides Python bindings to the OpenCASCADE
geometry kernel.

Copyright (C) 2016-2018  Laughlin Research, LLC (info@laughlinresearch.com)

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
*/
#include <pyOCCT_Common.hpp>

#include <Standard_Handle.hxx>
#include <Adaptor3d_TopolTool.hxx>
#include <GeomAdaptor_HSurface.hxx>
#include <IntPatch_Line.hxx>
#include <Standard_TypeDef.hxx>
#include <GeomInt_LineConstructor.hxx>
#include <NCollection_BaseVector.hxx>
#include <NCollection_BaseAllocator.hxx>
#include <NCollection_Vector.hxx>
#include <GeomInt_VectorOfReal.hxx>
#include <Geom_Surface.hxx>
#include <Geom_Curve.hxx>
#include <Geom2d_Curve.hxx>
#include <gp_Pnt.hxx>
#include <gp_Pnt2d.hxx>
#include <IntPatch_RLine.hxx>
#include <Bnd_Box2d.hxx>
#include <IntPatch_WLine.hxx>
#include <Geom2d_BSplineCurve.hxx>
#include <GeomInt_IntSS.hxx>
#include <IntPatch_Point.hxx>
#include <IntPatch_SequenceOfLine.hxx>
#include <GeomInt_LineTool.hxx>
#include <Adaptor3d_HSurface.hxx>
#include <Approx_ParametrizationType.hxx>
#include <AppParCurves_MultiBSpCurve.hxx>
#include <GeomInt_WLApprox.hxx>
#include <TopAbs_Orientation.hxx>
#include <GeomInt_ParameterAndOrientation.hxx>
#include <math_FunctionSetWithDerivatives.hxx>
#include <math_Vector.hxx>
#include <math_Matrix.hxx>
#include <IntImp_ConstIsoparametric.hxx>
#include <TColStd_Array1OfReal.hxx>
#include <gp_Dir.hxx>
#include <gp_Dir2d.hxx>
#include <GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox.hxx>
#include <math_FunctionSetRoot.hxx>
#include <IntSurf_PntOn2S.hxx>
#include <GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox.hxx>
#include <ApproxInt_SvSurfaces.hxx>
#include <gp_Vec.hxx>
#include <gp_Vec2d.hxx>
#include <GeomInt_ThePrmPrmSvSurfacesOfWLApprox.hxx>
#include <IntSurf_Quadric.hxx>
#include <GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox.hxx>
#include <GeomInt_TheImpPrmSvSurfacesOfWLApprox.hxx>
#include <Approx_Status.hxx>
#include <TColgp_Array1OfPnt.hxx>
#include <TColgp_Array1OfPnt2d.hxx>
#include <TColgp_Array1OfVec.hxx>
#include <TColgp_Array1OfVec2d.hxx>
#include <GeomInt_TheMultiLineOfWLApprox.hxx>
#include <GeomInt_TheMultiLineToolOfWLApprox.hxx>
#include <AppParCurves_Constraint.hxx>
#include <TColStd_Array1OfInteger.hxx>
#include <AppParCurves_MultiCurve.hxx>
#include <math_IntegerVector.hxx>
#include <GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox.hxx>
#include <math_MultipleVarFunctionWithGradient.hxx>
#include <AppParCurves_HArray1OfConstraintCouple.hxx>
#include <GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox.hxx>
#include <math_BFGS.hxx>
#include <GeomInt_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfWLApprox.hxx>
#include <GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox.hxx>
#include <GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox.hxx>
#include <GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox.hxx>
#include <GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox.hxx>
#include <GeomInt_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfWLApprox.hxx>
#include <GeomInt_MyGradientbisOfTheComputeLineOfWLApprox.hxx>
#include <GeomInt_TheComputeLineOfWLApprox.hxx>
#include <GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox.hxx>
#include <GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox.hxx>
#include <GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox.hxx>
#include <GeomInt_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfWLApprox.hxx>
#include <GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox.hxx>
#include <GeomInt_TheComputeLineBezierOfWLApprox.hxx>
#include <GeomInt.hxx>
#include <NCollection_BaseSequence.hxx>
#include <NCollection_Sequence.hxx>
#include <GeomInt_SequenceOfParameterAndOrientation.hxx>
#include <NCollection_Templates.hpp>

PYBIND11_MODULE(GeomInt, mod) {

	// IMPORT
	py::module::import("OCCT.Standard");
	py::module::import("OCCT.Adaptor3d");
	py::module::import("OCCT.GeomAdaptor");
	py::module::import("OCCT.IntPatch");
	py::module::import("OCCT.NCollection");
	py::module::import("OCCT.Geom");
	py::module::import("OCCT.Geom2d");
	py::module::import("OCCT.gp");
	py::module::import("OCCT.Bnd");
	py::module::import("OCCT.Approx");
	py::module::import("OCCT.AppParCurves");
	py::module::import("OCCT.TopAbs");
	py::module::import("OCCT.math");
	py::module::import("OCCT.IntImp");
	py::module::import("OCCT.TColStd");
	py::module::import("OCCT.IntSurf");
	py::module::import("OCCT.ApproxInt");
	py::module::import("OCCT.TColgp");

	py::module other_mod;

	// IMPORT GUARDS

	// ENUMS

	// FUNCTIONS

	// CLASSES
	// C:\Miniconda\envs\occt\Library\include\opencascade\GeomInt_LineConstructor.hxx
	py::class_<GeomInt_LineConstructor, std::unique_ptr<GeomInt_LineConstructor, Deleter<GeomInt_LineConstructor>>> cls_GeomInt_LineConstructor(mod, "GeomInt_LineConstructor", "Splits given Line.");
	cls_GeomInt_LineConstructor.def(py::init<>());
	cls_GeomInt_LineConstructor.def("Load", (void (GeomInt_LineConstructor::*)(const opencascade::handle<Adaptor3d_TopolTool> &, const opencascade::handle<Adaptor3d_TopolTool> &, const opencascade::handle<GeomAdaptor_HSurface> &, const opencascade::handle<GeomAdaptor_HSurface> &)) &GeomInt_LineConstructor::Load, "Initializes me by two surfaces and corresponding tools which represent boundaries of surfaces", py::arg("D1"), py::arg("D2"), py::arg("S1"), py::arg("S2"));
	cls_GeomInt_LineConstructor.def("Perform", (void (GeomInt_LineConstructor::*)(const opencascade::handle<IntPatch_Line> &)) &GeomInt_LineConstructor::Perform, "Splits line", py::arg("L"));
	cls_GeomInt_LineConstructor.def("IsDone", (Standard_Boolean (GeomInt_LineConstructor::*)() const ) &GeomInt_LineConstructor::IsDone, "Returns True if splitting was successful");
	cls_GeomInt_LineConstructor.def("NbParts", (Standard_Integer (GeomInt_LineConstructor::*)() const ) &GeomInt_LineConstructor::NbParts, "Returns number of splits");
	cls_GeomInt_LineConstructor.def("Part", [](GeomInt_LineConstructor &self, const Standard_Integer I, Standard_Real & WFirst, Standard_Real & WLast){ self.Part(I, WFirst, WLast); return std::tuple<Standard_Real &, Standard_Real &>(WFirst, WLast); }, "Return first and last parameters for given index of split", py::arg("I"), py::arg("WFirst"), py::arg("WLast"));

	// C:\Miniconda\envs\occt\Library\include\opencascade\GeomInt_IntSS.hxx
	py::class_<GeomInt_IntSS, std::unique_ptr<GeomInt_IntSS, Deleter<GeomInt_IntSS>>> cls_GeomInt_IntSS(mod, "GeomInt_IntSS", "None");
	cls_GeomInt_IntSS.def(py::init<>());
	cls_GeomInt_IntSS.def(py::init<const opencascade::handle<Geom_Surface> &, const opencascade::handle<Geom_Surface> &, const Standard_Real>(), py::arg("S1"), py::arg("S2"), py::arg("Tol"));
	cls_GeomInt_IntSS.def(py::init<const opencascade::handle<Geom_Surface> &, const opencascade::handle<Geom_Surface> &, const Standard_Real, const Standard_Boolean>(), py::arg("S1"), py::arg("S2"), py::arg("Tol"), py::arg("Approx"));
	cls_GeomInt_IntSS.def(py::init<const opencascade::handle<Geom_Surface> &, const opencascade::handle<Geom_Surface> &, const Standard_Real, const Standard_Boolean, const Standard_Boolean>(), py::arg("S1"), py::arg("S2"), py::arg("Tol"), py::arg("Approx"), py::arg("ApproxS1"));
	cls_GeomInt_IntSS.def(py::init<const opencascade::handle<Geom_Surface> &, const opencascade::handle<Geom_Surface> &, const Standard_Real, const Standard_Boolean, const Standard_Boolean, const Standard_Boolean>(), py::arg("S1"), py::arg("S2"), py::arg("Tol"), py::arg("Approx"), py::arg("ApproxS1"), py::arg("ApproxS2"));
	cls_GeomInt_IntSS.def("Perform", [](GeomInt_IntSS &self, const opencascade::handle<Geom_Surface> & a0, const opencascade::handle<Geom_Surface> & a1, const Standard_Real a2) -> void { return self.Perform(a0, a1, a2); }, py::arg("S1"), py::arg("S2"), py::arg("Tol"));
	cls_GeomInt_IntSS.def("Perform", [](GeomInt_IntSS &self, const opencascade::handle<Geom_Surface> & a0, const opencascade::handle<Geom_Surface> & a1, const Standard_Real a2, const Standard_Boolean a3) -> void { return self.Perform(a0, a1, a2, a3); }, py::arg("S1"), py::arg("S2"), py::arg("Tol"), py::arg("Approx"));
	cls_GeomInt_IntSS.def("Perform", [](GeomInt_IntSS &self, const opencascade::handle<Geom_Surface> & a0, const opencascade::handle<Geom_Surface> & a1, const Standard_Real a2, const Standard_Boolean a3, const Standard_Boolean a4) -> void { return self.Perform(a0, a1, a2, a3, a4); }, py::arg("S1"), py::arg("S2"), py::arg("Tol"), py::arg("Approx"), py::arg("ApproxS1"));
	cls_GeomInt_IntSS.def("Perform", (void (GeomInt_IntSS::*)(const opencascade::handle<Geom_Surface> &, const opencascade::handle<Geom_Surface> &, const Standard_Real, const Standard_Boolean, const Standard_Boolean, const Standard_Boolean)) &GeomInt_IntSS::Perform, "general intersection of two surfaces", py::arg("S1"), py::arg("S2"), py::arg("Tol"), py::arg("Approx"), py::arg("ApproxS1"), py::arg("ApproxS2"));
	cls_GeomInt_IntSS.def("Perform", [](GeomInt_IntSS &self, const opencascade::handle<GeomAdaptor_HSurface> & a0, const opencascade::handle<GeomAdaptor_HSurface> & a1, const Standard_Real a2) -> void { return self.Perform(a0, a1, a2); }, py::arg("HS1"), py::arg("HS2"), py::arg("Tol"));
	cls_GeomInt_IntSS.def("Perform", [](GeomInt_IntSS &self, const opencascade::handle<GeomAdaptor_HSurface> & a0, const opencascade::handle<GeomAdaptor_HSurface> & a1, const Standard_Real a2, const Standard_Boolean a3) -> void { return self.Perform(a0, a1, a2, a3); }, py::arg("HS1"), py::arg("HS2"), py::arg("Tol"), py::arg("Approx"));
	cls_GeomInt_IntSS.def("Perform", [](GeomInt_IntSS &self, const opencascade::handle<GeomAdaptor_HSurface> & a0, const opencascade::handle<GeomAdaptor_HSurface> & a1, const Standard_Real a2, const Standard_Boolean a3, const Standard_Boolean a4) -> void { return self.Perform(a0, a1, a2, a3, a4); }, py::arg("HS1"), py::arg("HS2"), py::arg("Tol"), py::arg("Approx"), py::arg("ApproxS1"));
	cls_GeomInt_IntSS.def("Perform", (void (GeomInt_IntSS::*)(const opencascade::handle<GeomAdaptor_HSurface> &, const opencascade::handle<GeomAdaptor_HSurface> &, const Standard_Real, const Standard_Boolean, const Standard_Boolean, const Standard_Boolean)) &GeomInt_IntSS::Perform, "intersection of adapted surfaces", py::arg("HS1"), py::arg("HS2"), py::arg("Tol"), py::arg("Approx"), py::arg("ApproxS1"), py::arg("ApproxS2"));
	cls_GeomInt_IntSS.def("Perform", [](GeomInt_IntSS &self, const opencascade::handle<Geom_Surface> & a0, const opencascade::handle<Geom_Surface> & a1, const Standard_Real a2, const Standard_Real a3, const Standard_Real a4, const Standard_Real a5, const Standard_Real a6) -> void { return self.Perform(a0, a1, a2, a3, a4, a5, a6); }, py::arg("S1"), py::arg("S2"), py::arg("Tol"), py::arg("U1"), py::arg("V1"), py::arg("U2"), py::arg("V2"));
	cls_GeomInt_IntSS.def("Perform", [](GeomInt_IntSS &self, const opencascade::handle<Geom_Surface> & a0, const opencascade::handle<Geom_Surface> & a1, const Standard_Real a2, const Standard_Real a3, const Standard_Real a4, const Standard_Real a5, const Standard_Real a6, const Standard_Boolean a7) -> void { return self.Perform(a0, a1, a2, a3, a4, a5, a6, a7); }, py::arg("S1"), py::arg("S2"), py::arg("Tol"), py::arg("U1"), py::arg("V1"), py::arg("U2"), py::arg("V2"), py::arg("Approx"));
	cls_GeomInt_IntSS.def("Perform", [](GeomInt_IntSS &self, const opencascade::handle<Geom_Surface> & a0, const opencascade::handle<Geom_Surface> & a1, const Standard_Real a2, const Standard_Real a3, const Standard_Real a4, const Standard_Real a5, const Standard_Real a6, const Standard_Boolean a7, const Standard_Boolean a8) -> void { return self.Perform(a0, a1, a2, a3, a4, a5, a6, a7, a8); }, py::arg("S1"), py::arg("S2"), py::arg("Tol"), py::arg("U1"), py::arg("V1"), py::arg("U2"), py::arg("V2"), py::arg("Approx"), py::arg("ApproxS1"));
	cls_GeomInt_IntSS.def("Perform", (void (GeomInt_IntSS::*)(const opencascade::handle<Geom_Surface> &, const opencascade::handle<Geom_Surface> &, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Boolean, const Standard_Boolean, const Standard_Boolean)) &GeomInt_IntSS::Perform, "general intersection using a starting point", py::arg("S1"), py::arg("S2"), py::arg("Tol"), py::arg("U1"), py::arg("V1"), py::arg("U2"), py::arg("V2"), py::arg("Approx"), py::arg("ApproxS1"), py::arg("ApproxS2"));
	cls_GeomInt_IntSS.def("Perform", [](GeomInt_IntSS &self, const opencascade::handle<GeomAdaptor_HSurface> & a0, const opencascade::handle<GeomAdaptor_HSurface> & a1, const Standard_Real a2, const Standard_Real a3, const Standard_Real a4, const Standard_Real a5, const Standard_Real a6) -> void { return self.Perform(a0, a1, a2, a3, a4, a5, a6); }, py::arg("HS1"), py::arg("HS2"), py::arg("Tol"), py::arg("U1"), py::arg("V1"), py::arg("U2"), py::arg("V2"));
	cls_GeomInt_IntSS.def("Perform", [](GeomInt_IntSS &self, const opencascade::handle<GeomAdaptor_HSurface> & a0, const opencascade::handle<GeomAdaptor_HSurface> & a1, const Standard_Real a2, const Standard_Real a3, const Standard_Real a4, const Standard_Real a5, const Standard_Real a6, const Standard_Boolean a7) -> void { return self.Perform(a0, a1, a2, a3, a4, a5, a6, a7); }, py::arg("HS1"), py::arg("HS2"), py::arg("Tol"), py::arg("U1"), py::arg("V1"), py::arg("U2"), py::arg("V2"), py::arg("Approx"));
	cls_GeomInt_IntSS.def("Perform", [](GeomInt_IntSS &self, const opencascade::handle<GeomAdaptor_HSurface> & a0, const opencascade::handle<GeomAdaptor_HSurface> & a1, const Standard_Real a2, const Standard_Real a3, const Standard_Real a4, const Standard_Real a5, const Standard_Real a6, const Standard_Boolean a7, const Standard_Boolean a8) -> void { return self.Perform(a0, a1, a2, a3, a4, a5, a6, a7, a8); }, py::arg("HS1"), py::arg("HS2"), py::arg("Tol"), py::arg("U1"), py::arg("V1"), py::arg("U2"), py::arg("V2"), py::arg("Approx"), py::arg("ApproxS1"));
	cls_GeomInt_IntSS.def("Perform", (void (GeomInt_IntSS::*)(const opencascade::handle<GeomAdaptor_HSurface> &, const opencascade::handle<GeomAdaptor_HSurface> &, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Boolean, const Standard_Boolean, const Standard_Boolean)) &GeomInt_IntSS::Perform, "intersection of adapted surfaces using a starting point", py::arg("HS1"), py::arg("HS2"), py::arg("Tol"), py::arg("U1"), py::arg("V1"), py::arg("U2"), py::arg("V2"), py::arg("Approx"), py::arg("ApproxS1"), py::arg("ApproxS2"));
	cls_GeomInt_IntSS.def("IsDone", (Standard_Boolean (GeomInt_IntSS::*)() const ) &GeomInt_IntSS::IsDone, "None");
	cls_GeomInt_IntSS.def("TolReached3d", (Standard_Real (GeomInt_IntSS::*)() const ) &GeomInt_IntSS::TolReached3d, "None");
	cls_GeomInt_IntSS.def("TolReached2d", (Standard_Real (GeomInt_IntSS::*)() const ) &GeomInt_IntSS::TolReached2d, "None");
	cls_GeomInt_IntSS.def("NbLines", (Standard_Integer (GeomInt_IntSS::*)() const ) &GeomInt_IntSS::NbLines, "None");
	cls_GeomInt_IntSS.def("Line", (const opencascade::handle<Geom_Curve> & (GeomInt_IntSS::*)(const Standard_Integer) const ) &GeomInt_IntSS::Line, "None", py::arg("Index"));
	cls_GeomInt_IntSS.def("HasLineOnS1", (Standard_Boolean (GeomInt_IntSS::*)(const Standard_Integer) const ) &GeomInt_IntSS::HasLineOnS1, "None", py::arg("Index"));
	cls_GeomInt_IntSS.def("LineOnS1", (const opencascade::handle<Geom2d_Curve> & (GeomInt_IntSS::*)(const Standard_Integer) const ) &GeomInt_IntSS::LineOnS1, "None", py::arg("Index"));
	cls_GeomInt_IntSS.def("HasLineOnS2", (Standard_Boolean (GeomInt_IntSS::*)(const Standard_Integer) const ) &GeomInt_IntSS::HasLineOnS2, "None", py::arg("Index"));
	cls_GeomInt_IntSS.def("LineOnS2", (const opencascade::handle<Geom2d_Curve> & (GeomInt_IntSS::*)(const Standard_Integer) const ) &GeomInt_IntSS::LineOnS2, "None", py::arg("Index"));
	cls_GeomInt_IntSS.def("NbBoundaries", (Standard_Integer (GeomInt_IntSS::*)() const ) &GeomInt_IntSS::NbBoundaries, "None");
	cls_GeomInt_IntSS.def("Boundary", (const opencascade::handle<Geom_Curve> & (GeomInt_IntSS::*)(const Standard_Integer) const ) &GeomInt_IntSS::Boundary, "None", py::arg("Index"));
	cls_GeomInt_IntSS.def("NbPoints", (Standard_Integer (GeomInt_IntSS::*)() const ) &GeomInt_IntSS::NbPoints, "None");
	cls_GeomInt_IntSS.def("Point", (gp_Pnt (GeomInt_IntSS::*)(const Standard_Integer) const ) &GeomInt_IntSS::Point, "None", py::arg("Index"));
	cls_GeomInt_IntSS.def("Pnt2d", (gp_Pnt2d (GeomInt_IntSS::*)(const Standard_Integer, const Standard_Boolean) const ) &GeomInt_IntSS::Pnt2d, "None", py::arg("Index"), py::arg("OnFirst"));
	// cls_GeomInt_IntSS.def("SetTolFixTangents", (void (GeomInt_IntSS::*)(const Standard_Real, const Standard_Real)) &GeomInt_IntSS::SetTolFixTangents, "None", py::arg("aTolCheck"), py::arg("aTolAngCheck"));
	// cls_GeomInt_IntSS.def("TolFixTangents", [](GeomInt_IntSS &self, Standard_Real & aTolCheck, Standard_Real & aTolAngCheck){ self.TolFixTangents(aTolCheck, aTolAngCheck); return std::tuple<Standard_Real &, Standard_Real &>(aTolCheck, aTolAngCheck); }, "None", py::arg("aTolCheck"), py::arg("aTolAngCheck"));
	cls_GeomInt_IntSS.def_static("TreatRLine_", [](const opencascade::handle<IntPatch_RLine> & theRL, const opencascade::handle<GeomAdaptor_HSurface> & theHS1, const opencascade::handle<GeomAdaptor_HSurface> & theHS2, opencascade::handle<Geom_Curve> & theC3d, opencascade::handle<Geom2d_Curve> & theC2d1, opencascade::handle<Geom2d_Curve> & theC2d2, Standard_Real & theTolReached){ GeomInt_IntSS::TreatRLine(theRL, theHS1, theHS2, theC3d, theC2d1, theC2d2, theTolReached); return theTolReached; }, "converts RLine to Geom(2d)_Curve.", py::arg("theRL"), py::arg("theHS1"), py::arg("theHS2"), py::arg("theC3d"), py::arg("theC2d1"), py::arg("theC2d2"), py::arg("theTolReached"));
	cls_GeomInt_IntSS.def_static("BuildPCurves_", [](const Standard_Real f, const Standard_Real l, Standard_Real & Tol, const opencascade::handle<Geom_Surface> & S, const opencascade::handle<Geom_Curve> & C, opencascade::handle<Geom2d_Curve> & C2d){ GeomInt_IntSS::BuildPCurves(f, l, Tol, S, C, C2d); return Tol; }, "creates 2D-curve on given surface from given 3D-curve", py::arg("f"), py::arg("l"), py::arg("Tol"), py::arg("S"), py::arg("C"), py::arg("C2d"));
	cls_GeomInt_IntSS.def_static("TrimILineOnSurfBoundaries_", (void (*)(const opencascade::handle<Geom2d_Curve> &, const opencascade::handle<Geom2d_Curve> &, const Bnd_Box2d &, const Bnd_Box2d &, GeomInt_VectorOfReal &)) &GeomInt_IntSS::TrimILineOnSurfBoundaries, "puts into theArrayOfParameters the parameters of intersection points of given theC2d1 and theC2d2 curves with the boundaries of the source surface.", py::arg("theC2d1"), py::arg("theC2d2"), py::arg("theBound1"), py::arg("theBound2"), py::arg("theArrayOfParameters"));
	cls_GeomInt_IntSS.def_static("MakeBSpline_", (opencascade::handle<Geom_Curve> (*)(const opencascade::handle<IntPatch_WLine> &, const Standard_Integer, const Standard_Integer)) &GeomInt_IntSS::MakeBSpline, "None", py::arg("WL"), py::arg("ideb"), py::arg("ifin"));
	cls_GeomInt_IntSS.def_static("MakeBSpline2d_", (opencascade::handle<Geom2d_BSplineCurve> (*)(const opencascade::handle<IntPatch_WLine> &, const Standard_Integer, const Standard_Integer, const Standard_Boolean)) &GeomInt_IntSS::MakeBSpline2d, "None", py::arg("theWLine"), py::arg("ideb"), py::arg("ifin"), py::arg("onFirst"));

	// C:\Miniconda\envs\occt\Library\include\opencascade\GeomInt_LineTool.hxx
	py::class_<GeomInt_LineTool, std::unique_ptr<GeomInt_LineTool, Deleter<GeomInt_LineTool>>> cls_GeomInt_LineTool(mod, "GeomInt_LineTool", "None");
	cls_GeomInt_LineTool.def(py::init<>());
	cls_GeomInt_LineTool.def_static("NbVertex_", (Standard_Integer (*)(const opencascade::handle<IntPatch_Line> &)) &GeomInt_LineTool::NbVertex, "None", py::arg("L"));
	cls_GeomInt_LineTool.def_static("Vertex_", (const IntPatch_Point & (*)(const opencascade::handle<IntPatch_Line> &, const Standard_Integer)) &GeomInt_LineTool::Vertex, "None", py::arg("L"), py::arg("I"));
	cls_GeomInt_LineTool.def_static("FirstParameter_", (Standard_Real (*)(const opencascade::handle<IntPatch_Line> &)) &GeomInt_LineTool::FirstParameter, "None", py::arg("L"));
	cls_GeomInt_LineTool.def_static("LastParameter_", (Standard_Real (*)(const opencascade::handle<IntPatch_Line> &)) &GeomInt_LineTool::LastParameter, "None", py::arg("L"));
	cls_GeomInt_LineTool.def_static("DecompositionOfWLine_", (Standard_Boolean (*)(const opencascade::handle<IntPatch_WLine> &, const opencascade::handle<GeomAdaptor_HSurface> &, const opencascade::handle<GeomAdaptor_HSurface> &, const Standard_Real, const GeomInt_LineConstructor &, IntPatch_SequenceOfLine &)) &GeomInt_LineTool::DecompositionOfWLine, "None", py::arg("theWLine"), py::arg("theSurface1"), py::arg("theSurface2"), py::arg("aTolSum"), py::arg("theLConstructor"), py::arg("theNewLines"));

	// C:\Miniconda\envs\occt\Library\include\opencascade\GeomInt_WLApprox.hxx
	py::class_<GeomInt_WLApprox, std::unique_ptr<GeomInt_WLApprox, Deleter<GeomInt_WLApprox>>> cls_GeomInt_WLApprox(mod, "GeomInt_WLApprox", "None");
	cls_GeomInt_WLApprox.def(py::init<>());
	cls_GeomInt_WLApprox.def("Perform", [](GeomInt_WLApprox &self, const opencascade::handle<Adaptor3d_HSurface> & a0, const opencascade::handle<Adaptor3d_HSurface> & a1, const opencascade::handle<IntPatch_WLine> & a2) -> void { return self.Perform(a0, a1, a2); }, py::arg("Surf1"), py::arg("Surf2"), py::arg("aLine"));
	cls_GeomInt_WLApprox.def("Perform", [](GeomInt_WLApprox &self, const opencascade::handle<Adaptor3d_HSurface> & a0, const opencascade::handle<Adaptor3d_HSurface> & a1, const opencascade::handle<IntPatch_WLine> & a2, const Standard_Boolean a3) -> void { return self.Perform(a0, a1, a2, a3); }, py::arg("Surf1"), py::arg("Surf2"), py::arg("aLine"), py::arg("ApproxXYZ"));
	cls_GeomInt_WLApprox.def("Perform", [](GeomInt_WLApprox &self, const opencascade::handle<Adaptor3d_HSurface> & a0, const opencascade::handle<Adaptor3d_HSurface> & a1, const opencascade::handle<IntPatch_WLine> & a2, const Standard_Boolean a3, const Standard_Boolean a4) -> void { return self.Perform(a0, a1, a2, a3, a4); }, py::arg("Surf1"), py::arg("Surf2"), py::arg("aLine"), py::arg("ApproxXYZ"), py::arg("ApproxU1V1"));
	cls_GeomInt_WLApprox.def("Perform", [](GeomInt_WLApprox &self, const opencascade::handle<Adaptor3d_HSurface> & a0, const opencascade::handle<Adaptor3d_HSurface> & a1, const opencascade::handle<IntPatch_WLine> & a2, const Standard_Boolean a3, const Standard_Boolean a4, const Standard_Boolean a5) -> void { return self.Perform(a0, a1, a2, a3, a4, a5); }, py::arg("Surf1"), py::arg("Surf2"), py::arg("aLine"), py::arg("ApproxXYZ"), py::arg("ApproxU1V1"), py::arg("ApproxU2V2"));
	cls_GeomInt_WLApprox.def("Perform", [](GeomInt_WLApprox &self, const opencascade::handle<Adaptor3d_HSurface> & a0, const opencascade::handle<Adaptor3d_HSurface> & a1, const opencascade::handle<IntPatch_WLine> & a2, const Standard_Boolean a3, const Standard_Boolean a4, const Standard_Boolean a5, const Standard_Integer a6) -> void { return self.Perform(a0, a1, a2, a3, a4, a5, a6); }, py::arg("Surf1"), py::arg("Surf2"), py::arg("aLine"), py::arg("ApproxXYZ"), py::arg("ApproxU1V1"), py::arg("ApproxU2V2"), py::arg("indicemin"));
	cls_GeomInt_WLApprox.def("Perform", (void (GeomInt_WLApprox::*)(const opencascade::handle<Adaptor3d_HSurface> &, const opencascade::handle<Adaptor3d_HSurface> &, const opencascade::handle<IntPatch_WLine> &, const Standard_Boolean, const Standard_Boolean, const Standard_Boolean, const Standard_Integer, const Standard_Integer)) &GeomInt_WLApprox::Perform, "None", py::arg("Surf1"), py::arg("Surf2"), py::arg("aLine"), py::arg("ApproxXYZ"), py::arg("ApproxU1V1"), py::arg("ApproxU2V2"), py::arg("indicemin"), py::arg("indicemax"));
	cls_GeomInt_WLApprox.def("Perform", [](GeomInt_WLApprox &self, const opencascade::handle<IntPatch_WLine> & a0) -> void { return self.Perform(a0); }, py::arg("aLine"));
	cls_GeomInt_WLApprox.def("Perform", [](GeomInt_WLApprox &self, const opencascade::handle<IntPatch_WLine> & a0, const Standard_Boolean a1) -> void { return self.Perform(a0, a1); }, py::arg("aLine"), py::arg("ApproxXYZ"));
	cls_GeomInt_WLApprox.def("Perform", [](GeomInt_WLApprox &self, const opencascade::handle<IntPatch_WLine> & a0, const Standard_Boolean a1, const Standard_Boolean a2) -> void { return self.Perform(a0, a1, a2); }, py::arg("aLine"), py::arg("ApproxXYZ"), py::arg("ApproxU1V1"));
	cls_GeomInt_WLApprox.def("Perform", [](GeomInt_WLApprox &self, const opencascade::handle<IntPatch_WLine> & a0, const Standard_Boolean a1, const Standard_Boolean a2, const Standard_Boolean a3) -> void { return self.Perform(a0, a1, a2, a3); }, py::arg("aLine"), py::arg("ApproxXYZ"), py::arg("ApproxU1V1"), py::arg("ApproxU2V2"));
	cls_GeomInt_WLApprox.def("Perform", [](GeomInt_WLApprox &self, const opencascade::handle<IntPatch_WLine> & a0, const Standard_Boolean a1, const Standard_Boolean a2, const Standard_Boolean a3, const Standard_Integer a4) -> void { return self.Perform(a0, a1, a2, a3, a4); }, py::arg("aLine"), py::arg("ApproxXYZ"), py::arg("ApproxU1V1"), py::arg("ApproxU2V2"), py::arg("indicemin"));
	cls_GeomInt_WLApprox.def("Perform", (void (GeomInt_WLApprox::*)(const opencascade::handle<IntPatch_WLine> &, const Standard_Boolean, const Standard_Boolean, const Standard_Boolean, const Standard_Integer, const Standard_Integer)) &GeomInt_WLApprox::Perform, "None", py::arg("aLine"), py::arg("ApproxXYZ"), py::arg("ApproxU1V1"), py::arg("ApproxU2V2"), py::arg("indicemin"), py::arg("indicemax"));
	cls_GeomInt_WLApprox.def("SetParameters", [](GeomInt_WLApprox &self, const Standard_Real a0, const Standard_Real a1, const Standard_Integer a2, const Standard_Integer a3, const Standard_Integer a4) -> void { return self.SetParameters(a0, a1, a2, a3, a4); }, py::arg("Tol3d"), py::arg("Tol2d"), py::arg("DegMin"), py::arg("DegMax"), py::arg("NbIterMax"));
	cls_GeomInt_WLApprox.def("SetParameters", [](GeomInt_WLApprox &self, const Standard_Real a0, const Standard_Real a1, const Standard_Integer a2, const Standard_Integer a3, const Standard_Integer a4, const Standard_Integer a5) -> void { return self.SetParameters(a0, a1, a2, a3, a4, a5); }, py::arg("Tol3d"), py::arg("Tol2d"), py::arg("DegMin"), py::arg("DegMax"), py::arg("NbIterMax"), py::arg("NbPntMax"));
	cls_GeomInt_WLApprox.def("SetParameters", [](GeomInt_WLApprox &self, const Standard_Real a0, const Standard_Real a1, const Standard_Integer a2, const Standard_Integer a3, const Standard_Integer a4, const Standard_Integer a5, const Standard_Boolean a6) -> void { return self.SetParameters(a0, a1, a2, a3, a4, a5, a6); }, py::arg("Tol3d"), py::arg("Tol2d"), py::arg("DegMin"), py::arg("DegMax"), py::arg("NbIterMax"), py::arg("NbPntMax"), py::arg("ApproxWithTangency"));
	cls_GeomInt_WLApprox.def("SetParameters", (void (GeomInt_WLApprox::*)(const Standard_Real, const Standard_Real, const Standard_Integer, const Standard_Integer, const Standard_Integer, const Standard_Integer, const Standard_Boolean, const Approx_ParametrizationType)) &GeomInt_WLApprox::SetParameters, "None", py::arg("Tol3d"), py::arg("Tol2d"), py::arg("DegMin"), py::arg("DegMax"), py::arg("NbIterMax"), py::arg("NbPntMax"), py::arg("ApproxWithTangency"), py::arg("Parametrization"));
	// cls_GeomInt_WLApprox.def("Perform", (void (GeomInt_WLApprox::*)()) &GeomInt_WLApprox::Perform, "None");
	cls_GeomInt_WLApprox.def("TolReached3d", (Standard_Real (GeomInt_WLApprox::*)() const ) &GeomInt_WLApprox::TolReached3d, "None");
	cls_GeomInt_WLApprox.def("TolReached2d", (Standard_Real (GeomInt_WLApprox::*)() const ) &GeomInt_WLApprox::TolReached2d, "None");
	cls_GeomInt_WLApprox.def("IsDone", (Standard_Boolean (GeomInt_WLApprox::*)() const ) &GeomInt_WLApprox::IsDone, "None");
	cls_GeomInt_WLApprox.def("NbMultiCurves", (Standard_Integer (GeomInt_WLApprox::*)() const ) &GeomInt_WLApprox::NbMultiCurves, "None");
	cls_GeomInt_WLApprox.def("Value", (const AppParCurves_MultiBSpCurve & (GeomInt_WLApprox::*)(const Standard_Integer) const ) &GeomInt_WLApprox::Value, "None", py::arg("Index"));

	// C:\Miniconda\envs\occt\Library\include\opencascade\GeomInt_ParameterAndOrientation.hxx
	py::class_<GeomInt_ParameterAndOrientation, std::unique_ptr<GeomInt_ParameterAndOrientation, Deleter<GeomInt_ParameterAndOrientation>>> cls_GeomInt_ParameterAndOrientation(mod, "GeomInt_ParameterAndOrientation", "None");
	cls_GeomInt_ParameterAndOrientation.def(py::init<>());
	cls_GeomInt_ParameterAndOrientation.def(py::init<const Standard_Real, const TopAbs_Orientation, const TopAbs_Orientation>(), py::arg("P"), py::arg("Or1"), py::arg("Or2"));
	cls_GeomInt_ParameterAndOrientation.def("SetOrientation1", (void (GeomInt_ParameterAndOrientation::*)(const TopAbs_Orientation)) &GeomInt_ParameterAndOrientation::SetOrientation1, "None", py::arg("Or"));
	cls_GeomInt_ParameterAndOrientation.def("SetOrientation2", (void (GeomInt_ParameterAndOrientation::*)(const TopAbs_Orientation)) &GeomInt_ParameterAndOrientation::SetOrientation2, "None", py::arg("Or"));
	cls_GeomInt_ParameterAndOrientation.def("Parameter", (Standard_Real (GeomInt_ParameterAndOrientation::*)() const ) &GeomInt_ParameterAndOrientation::Parameter, "None");
	cls_GeomInt_ParameterAndOrientation.def("Orientation1", (TopAbs_Orientation (GeomInt_ParameterAndOrientation::*)() const ) &GeomInt_ParameterAndOrientation::Orientation1, "None");
	cls_GeomInt_ParameterAndOrientation.def("Orientation2", (TopAbs_Orientation (GeomInt_ParameterAndOrientation::*)() const ) &GeomInt_ParameterAndOrientation::Orientation2, "None");

	// C:\Miniconda\envs\occt\Library\include\opencascade\GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox.hxx
	py::class_<GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox, std::unique_ptr<GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox, Deleter<GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox>>, math_FunctionSetWithDerivatives> cls_GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox(mod, "GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox", "None");
	cls_GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox.def(py::init<const opencascade::handle<Adaptor3d_HSurface> &, const opencascade::handle<Adaptor3d_HSurface> &>(), py::arg("S1"), py::arg("S2"));
	cls_GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox.def("NbVariables", (Standard_Integer (GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox::*)() const ) &GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox::NbVariables, "None");
	cls_GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox.def("NbEquations", (Standard_Integer (GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox::*)() const ) &GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox::NbEquations, "None");
	cls_GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox.def("Value", (Standard_Boolean (GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox::*)(const math_Vector &, math_Vector &)) &GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox::Value, "None", py::arg("X"), py::arg("F"));
	cls_GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox.def("Derivatives", (Standard_Boolean (GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox::*)(const math_Vector &, math_Matrix &)) &GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox::Derivatives, "None", py::arg("X"), py::arg("D"));
	cls_GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox.def("Values", (Standard_Boolean (GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox::*)(const math_Vector &, math_Vector &, math_Matrix &)) &GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox::Values, "None", py::arg("X"), py::arg("F"), py::arg("D"));
	cls_GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox.def("ComputeParameters", (void (GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox::*)(const IntImp_ConstIsoparametric, const TColStd_Array1OfReal &, math_Vector &, math_Vector &, math_Vector &, math_Vector &)) &GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox::ComputeParameters, "None", py::arg("ChoixIso"), py::arg("Param"), py::arg("UVap"), py::arg("BornInf"), py::arg("BornSup"), py::arg("Tolerance"));
	cls_GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox.def("Root", (Standard_Real (GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox::*)() const ) &GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox::Root, "returns somme des fi*fi");
	cls_GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox.def("Point", (gp_Pnt (GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox::*)() const ) &GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox::Point, "None");
	cls_GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox.def("IsTangent", (Standard_Boolean (GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox::*)(const math_Vector &, TColStd_Array1OfReal &, IntImp_ConstIsoparametric &)) &GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox::IsTangent, "None", py::arg("UVap"), py::arg("Param"), py::arg("BestChoix"));
	cls_GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox.def("Direction", (gp_Dir (GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox::*)() const ) &GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox::Direction, "None");
	cls_GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox.def("DirectionOnS1", (gp_Dir2d (GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox::*)() const ) &GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox::DirectionOnS1, "None");
	cls_GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox.def("DirectionOnS2", (gp_Dir2d (GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox::*)() const ) &GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox::DirectionOnS2, "None");
	cls_GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox.def("AuxillarSurface1", (const opencascade::handle<Adaptor3d_HSurface> & (GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox::*)() const ) &GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox::AuxillarSurface1, "None");
	cls_GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox.def("AuxillarSurface2", (const opencascade::handle<Adaptor3d_HSurface> & (GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox::*)() const ) &GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox::AuxillarSurface2, "None");

	// C:\Miniconda\envs\occt\Library\include\opencascade\GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox.hxx
	py::class_<GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox, std::unique_ptr<GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox, Deleter<GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox>>> cls_GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox(mod, "GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox", "None");
	cls_GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox.def(py::init<const TColStd_Array1OfReal &, const opencascade::handle<Adaptor3d_HSurface> &, const opencascade::handle<Adaptor3d_HSurface> &, const Standard_Real>(), py::arg("Param"), py::arg("S1"), py::arg("S2"), py::arg("TolTangency"));
	cls_GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox.def(py::init<const opencascade::handle<Adaptor3d_HSurface> &, const opencascade::handle<Adaptor3d_HSurface> &, const Standard_Real>(), py::arg("S1"), py::arg("S2"), py::arg("TolTangency"));
	cls_GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox.def("Perform", (IntImp_ConstIsoparametric (GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox::*)(const TColStd_Array1OfReal &, math_FunctionSetRoot &)) &GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox::Perform, "returns the best constant isoparametric to find the next intersection's point +stores the solution point (the solution point is found with the close point to intersect the isoparametric with the other patch; the choice of the isoparametic is calculated)", py::arg("Param"), py::arg("Rsnld"));
	cls_GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox.def("Perform", (IntImp_ConstIsoparametric (GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox::*)(const TColStd_Array1OfReal &, math_FunctionSetRoot &, const IntImp_ConstIsoparametric)) &GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox::Perform, "returns the best constant isoparametric to find the next intersection's point +stores the solution point (the solution point is found with the close point to intersect the isoparametric with the other patch; the choice of the isoparametic is given by ChoixIso)", py::arg("Param"), py::arg("Rsnld"), py::arg("ChoixIso"));
	cls_GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox.def("IsDone", (Standard_Boolean (GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox::*)() const ) &GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox::IsDone, "Returns TRUE if the creation completed without failure.");
	cls_GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox.def("IsEmpty", (Standard_Boolean (GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox::*)() const ) &GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox::IsEmpty, "Returns TRUE when there is no solution to the problem.");
	cls_GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox.def("Point", (const IntSurf_PntOn2S & (GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox::*)() const ) &GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox::Point, "Returns the intersection point.");
	cls_GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox.def("IsTangent", (Standard_Boolean (GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox::*)() const ) &GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox::IsTangent, "Returns True if the surfaces are tangent at the intersection point.");
	cls_GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox.def("Direction", (const gp_Dir & (GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox::*)() const ) &GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox::Direction, "Returns the tangent at the intersection line.");
	cls_GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox.def("DirectionOnS1", (const gp_Dir2d & (GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox::*)() const ) &GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox::DirectionOnS1, "Returns the tangent at the intersection line in the parametric space of the first surface.");
	cls_GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox.def("DirectionOnS2", (const gp_Dir2d & (GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox::*)() const ) &GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox::DirectionOnS2, "Returns the tangent at the intersection line in the parametric space of the second surface.");
	cls_GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox.def("Function", (GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox & (GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox::*)()) &GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox::Function, "return the math function which is used to compute the intersection");
	cls_GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox.def("ChangePoint", (IntSurf_PntOn2S & (GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox::*)()) &GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox::ChangePoint, "return the intersection point which is enable for changing.");

	// C:\Miniconda\envs\occt\Library\include\opencascade\GeomInt_ThePrmPrmSvSurfacesOfWLApprox.hxx
	py::class_<GeomInt_ThePrmPrmSvSurfacesOfWLApprox, std::unique_ptr<GeomInt_ThePrmPrmSvSurfacesOfWLApprox, Deleter<GeomInt_ThePrmPrmSvSurfacesOfWLApprox>>, ApproxInt_SvSurfaces> cls_GeomInt_ThePrmPrmSvSurfacesOfWLApprox(mod, "GeomInt_ThePrmPrmSvSurfacesOfWLApprox", "None");
	cls_GeomInt_ThePrmPrmSvSurfacesOfWLApprox.def(py::init<const opencascade::handle<Adaptor3d_HSurface> &, const opencascade::handle<Adaptor3d_HSurface> &>(), py::arg("Surf1"), py::arg("Surf2"));
	cls_GeomInt_ThePrmPrmSvSurfacesOfWLApprox.def("Compute", [](GeomInt_ThePrmPrmSvSurfacesOfWLApprox &self, Standard_Real & u1, Standard_Real & v1, Standard_Real & u2, Standard_Real & v2, gp_Pnt & Pt, gp_Vec & Tg, gp_Vec2d & Tguv1, gp_Vec2d & Tguv2){ Standard_Boolean rv = self.Compute(u1, v1, u2, v2, Pt, Tg, Tguv1, Tguv2); return std::tuple<Standard_Boolean, Standard_Real &, Standard_Real &, Standard_Real &, Standard_Real &>(rv, u1, v1, u2, v2); }, "returns True if Tg,Tguv1 Tguv2 can be computed.", py::arg("u1"), py::arg("v1"), py::arg("u2"), py::arg("v2"), py::arg("Pt"), py::arg("Tg"), py::arg("Tguv1"), py::arg("Tguv2"));
	cls_GeomInt_ThePrmPrmSvSurfacesOfWLApprox.def("Pnt", (void (GeomInt_ThePrmPrmSvSurfacesOfWLApprox::*)(const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, gp_Pnt &)) &GeomInt_ThePrmPrmSvSurfacesOfWLApprox::Pnt, "None", py::arg("u1"), py::arg("v1"), py::arg("u2"), py::arg("v2"), py::arg("P"));
	cls_GeomInt_ThePrmPrmSvSurfacesOfWLApprox.def("SeekPoint", (Standard_Boolean (GeomInt_ThePrmPrmSvSurfacesOfWLApprox::*)(const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, IntSurf_PntOn2S &)) &GeomInt_ThePrmPrmSvSurfacesOfWLApprox::SeekPoint, "None", py::arg("u1"), py::arg("v1"), py::arg("u2"), py::arg("v2"), py::arg("Point"));
	cls_GeomInt_ThePrmPrmSvSurfacesOfWLApprox.def("Tangency", (Standard_Boolean (GeomInt_ThePrmPrmSvSurfacesOfWLApprox::*)(const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, gp_Vec &)) &GeomInt_ThePrmPrmSvSurfacesOfWLApprox::Tangency, "None", py::arg("u1"), py::arg("v1"), py::arg("u2"), py::arg("v2"), py::arg("Tg"));
	cls_GeomInt_ThePrmPrmSvSurfacesOfWLApprox.def("TangencyOnSurf1", (Standard_Boolean (GeomInt_ThePrmPrmSvSurfacesOfWLApprox::*)(const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, gp_Vec2d &)) &GeomInt_ThePrmPrmSvSurfacesOfWLApprox::TangencyOnSurf1, "None", py::arg("u1"), py::arg("v1"), py::arg("u2"), py::arg("v2"), py::arg("Tg"));
	cls_GeomInt_ThePrmPrmSvSurfacesOfWLApprox.def("TangencyOnSurf2", (Standard_Boolean (GeomInt_ThePrmPrmSvSurfacesOfWLApprox::*)(const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, gp_Vec2d &)) &GeomInt_ThePrmPrmSvSurfacesOfWLApprox::TangencyOnSurf2, "None", py::arg("u1"), py::arg("v1"), py::arg("u2"), py::arg("v2"), py::arg("Tg"));

	// C:\Miniconda\envs\occt\Library\include\opencascade\GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox.hxx
	py::class_<GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox, std::unique_ptr<GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox, Deleter<GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox>>, math_FunctionSetWithDerivatives> cls_GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox(mod, "GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox", "None");
	cls_GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox.def(py::init<>());
	cls_GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox.def(py::init<const opencascade::handle<Adaptor3d_HSurface> &, const IntSurf_Quadric &>(), py::arg("PS"), py::arg("IS"));
	cls_GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox.def(py::init<const IntSurf_Quadric &>(), py::arg("IS"));
	cls_GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox.def("Set", (void (GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox::*)(const opencascade::handle<Adaptor3d_HSurface> &)) &GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox::Set, "None", py::arg("PS"));
	cls_GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox.def("SetImplicitSurface", (void (GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox::*)(const IntSurf_Quadric &)) &GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox::SetImplicitSurface, "None", py::arg("IS"));
	cls_GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox.def("Set", (void (GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox::*)(const Standard_Real)) &GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox::Set, "None", py::arg("Tolerance"));
	cls_GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox.def("NbVariables", (Standard_Integer (GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox::*)() const ) &GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox::NbVariables, "None");
	cls_GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox.def("NbEquations", (Standard_Integer (GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox::*)() const ) &GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox::NbEquations, "None");
	cls_GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox.def("Value", (Standard_Boolean (GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox::*)(const math_Vector &, math_Vector &)) &GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox::Value, "None", py::arg("X"), py::arg("F"));
	cls_GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox.def("Derivatives", (Standard_Boolean (GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox::*)(const math_Vector &, math_Matrix &)) &GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox::Derivatives, "None", py::arg("X"), py::arg("D"));
	cls_GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox.def("Values", (Standard_Boolean (GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox::*)(const math_Vector &, math_Vector &, math_Matrix &)) &GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox::Values, "None", py::arg("X"), py::arg("F"), py::arg("D"));
	cls_GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox.def("Root", (Standard_Real (GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox::*)() const ) &GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox::Root, "None");
	cls_GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox.def("Tolerance", (Standard_Real (GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox::*)() const ) &GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox::Tolerance, "Returns the value Tol so that if Abs(Func.Root())<Tol the function is considered null.");
	cls_GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox.def("Point", (const gp_Pnt & (GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox::*)() const ) &GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox::Point, "None");
	cls_GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox.def("IsTangent", (Standard_Boolean (GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox::*)()) &GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox::IsTangent, "None");
	cls_GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox.def("Direction3d", (const gp_Vec & (GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox::*)()) &GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox::Direction3d, "None");
	cls_GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox.def("Direction2d", (const gp_Dir2d & (GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox::*)()) &GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox::Direction2d, "None");
	cls_GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox.def("PSurface", (const opencascade::handle<Adaptor3d_HSurface> & (GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox::*)() const ) &GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox::PSurface, "None");
	cls_GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox.def("ISurface", (const IntSurf_Quadric & (GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox::*)() const ) &GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox::ISurface, "None");

	// C:\Miniconda\envs\occt\Library\include\opencascade\GeomInt_TheImpPrmSvSurfacesOfWLApprox.hxx
	py::class_<GeomInt_TheImpPrmSvSurfacesOfWLApprox, std::unique_ptr<GeomInt_TheImpPrmSvSurfacesOfWLApprox, Deleter<GeomInt_TheImpPrmSvSurfacesOfWLApprox>>, ApproxInt_SvSurfaces> cls_GeomInt_TheImpPrmSvSurfacesOfWLApprox(mod, "GeomInt_TheImpPrmSvSurfacesOfWLApprox", "None");
	cls_GeomInt_TheImpPrmSvSurfacesOfWLApprox.def(py::init<const opencascade::handle<Adaptor3d_HSurface> &, const IntSurf_Quadric &>(), py::arg("Surf1"), py::arg("Surf2"));
	cls_GeomInt_TheImpPrmSvSurfacesOfWLApprox.def(py::init<const IntSurf_Quadric &, const opencascade::handle<Adaptor3d_HSurface> &>(), py::arg("Surf1"), py::arg("Surf2"));
	cls_GeomInt_TheImpPrmSvSurfacesOfWLApprox.def("Compute", [](GeomInt_TheImpPrmSvSurfacesOfWLApprox &self, Standard_Real & u1, Standard_Real & v1, Standard_Real & u2, Standard_Real & v2, gp_Pnt & Pt, gp_Vec & Tg, gp_Vec2d & Tguv1, gp_Vec2d & Tguv2){ Standard_Boolean rv = self.Compute(u1, v1, u2, v2, Pt, Tg, Tguv1, Tguv2); return std::tuple<Standard_Boolean, Standard_Real &, Standard_Real &, Standard_Real &, Standard_Real &>(rv, u1, v1, u2, v2); }, "returns True if Tg,Tguv1 Tguv2 can be computed.", py::arg("u1"), py::arg("v1"), py::arg("u2"), py::arg("v2"), py::arg("Pt"), py::arg("Tg"), py::arg("Tguv1"), py::arg("Tguv2"));
	cls_GeomInt_TheImpPrmSvSurfacesOfWLApprox.def("Pnt", (void (GeomInt_TheImpPrmSvSurfacesOfWLApprox::*)(const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, gp_Pnt &)) &GeomInt_TheImpPrmSvSurfacesOfWLApprox::Pnt, "None", py::arg("u1"), py::arg("v1"), py::arg("u2"), py::arg("v2"), py::arg("P"));
	cls_GeomInt_TheImpPrmSvSurfacesOfWLApprox.def("SeekPoint", (Standard_Boolean (GeomInt_TheImpPrmSvSurfacesOfWLApprox::*)(const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, IntSurf_PntOn2S &)) &GeomInt_TheImpPrmSvSurfacesOfWLApprox::SeekPoint, "None", py::arg("u1"), py::arg("v1"), py::arg("u2"), py::arg("v2"), py::arg("Point"));
	cls_GeomInt_TheImpPrmSvSurfacesOfWLApprox.def("Tangency", (Standard_Boolean (GeomInt_TheImpPrmSvSurfacesOfWLApprox::*)(const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, gp_Vec &)) &GeomInt_TheImpPrmSvSurfacesOfWLApprox::Tangency, "None", py::arg("u1"), py::arg("v1"), py::arg("u2"), py::arg("v2"), py::arg("Tg"));
	cls_GeomInt_TheImpPrmSvSurfacesOfWLApprox.def("TangencyOnSurf1", (Standard_Boolean (GeomInt_TheImpPrmSvSurfacesOfWLApprox::*)(const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, gp_Vec2d &)) &GeomInt_TheImpPrmSvSurfacesOfWLApprox::TangencyOnSurf1, "None", py::arg("u1"), py::arg("v1"), py::arg("u2"), py::arg("v2"), py::arg("Tg"));
	cls_GeomInt_TheImpPrmSvSurfacesOfWLApprox.def("TangencyOnSurf2", (Standard_Boolean (GeomInt_TheImpPrmSvSurfacesOfWLApprox::*)(const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, gp_Vec2d &)) &GeomInt_TheImpPrmSvSurfacesOfWLApprox::TangencyOnSurf2, "None", py::arg("u1"), py::arg("v1"), py::arg("u2"), py::arg("v2"), py::arg("Tg"));
	// cls_GeomInt_TheImpPrmSvSurfacesOfWLApprox.def("FillInitialVectorOfSolution", [](GeomInt_TheImpPrmSvSurfacesOfWLApprox &self, const Standard_Real u1, const Standard_Real v1, const Standard_Real u2, const Standard_Real v2, const Standard_Real binfu, const Standard_Real bsupu, const Standard_Real binfv, const Standard_Real bsupv, math_Vector & X, Standard_Real & TranslationU, Standard_Real & TranslationV){ Standard_Boolean rv = self.FillInitialVectorOfSolution(u1, v1, u2, v2, binfu, bsupu, binfv, bsupv, X, TranslationU, TranslationV); return std::tuple<Standard_Boolean, Standard_Real &, Standard_Real &>(rv, TranslationU, TranslationV); }, "None", py::arg("u1"), py::arg("v1"), py::arg("u2"), py::arg("v2"), py::arg("binfu"), py::arg("bsupu"), py::arg("binfv"), py::arg("bsupv"), py::arg("X"), py::arg("TranslationU"), py::arg("TranslationV"));

	// C:\Miniconda\envs\occt\Library\include\opencascade\GeomInt_TheMultiLineOfWLApprox.hxx
	py::class_<GeomInt_TheMultiLineOfWLApprox, std::unique_ptr<GeomInt_TheMultiLineOfWLApprox, Deleter<GeomInt_TheMultiLineOfWLApprox>>> cls_GeomInt_TheMultiLineOfWLApprox(mod, "GeomInt_TheMultiLineOfWLApprox", "None");
	cls_GeomInt_TheMultiLineOfWLApprox.def(py::init<>());
	cls_GeomInt_TheMultiLineOfWLApprox.def(py::init<const opencascade::handle<IntPatch_WLine> &, const Standard_Address, const Standard_Integer, const Standard_Integer, const Standard_Boolean, const Standard_Boolean, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Boolean>(), py::arg("line"), py::arg("PtrSvSurfaces"), py::arg("NbP3d"), py::arg("NbP2d"), py::arg("ApproxU1V1"), py::arg("ApproxU2V2"), py::arg("xo"), py::arg("yo"), py::arg("zo"), py::arg("u1o"), py::arg("v1o"), py::arg("u2o"), py::arg("v2o"), py::arg("P2DOnFirst"));
	cls_GeomInt_TheMultiLineOfWLApprox.def(py::init<const opencascade::handle<IntPatch_WLine> &, const Standard_Address, const Standard_Integer, const Standard_Integer, const Standard_Boolean, const Standard_Boolean, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Boolean, const Standard_Integer>(), py::arg("line"), py::arg("PtrSvSurfaces"), py::arg("NbP3d"), py::arg("NbP2d"), py::arg("ApproxU1V1"), py::arg("ApproxU2V2"), py::arg("xo"), py::arg("yo"), py::arg("zo"), py::arg("u1o"), py::arg("v1o"), py::arg("u2o"), py::arg("v2o"), py::arg("P2DOnFirst"), py::arg("IndMin"));
	cls_GeomInt_TheMultiLineOfWLApprox.def(py::init<const opencascade::handle<IntPatch_WLine> &, const Standard_Address, const Standard_Integer, const Standard_Integer, const Standard_Boolean, const Standard_Boolean, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Boolean, const Standard_Integer, const Standard_Integer>(), py::arg("line"), py::arg("PtrSvSurfaces"), py::arg("NbP3d"), py::arg("NbP2d"), py::arg("ApproxU1V1"), py::arg("ApproxU2V2"), py::arg("xo"), py::arg("yo"), py::arg("zo"), py::arg("u1o"), py::arg("v1o"), py::arg("u2o"), py::arg("v2o"), py::arg("P2DOnFirst"), py::arg("IndMin"), py::arg("IndMax"));
	cls_GeomInt_TheMultiLineOfWLApprox.def(py::init<const opencascade::handle<IntPatch_WLine> &, const Standard_Integer, const Standard_Integer, const Standard_Boolean, const Standard_Boolean, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Boolean>(), py::arg("line"), py::arg("NbP3d"), py::arg("NbP2d"), py::arg("ApproxU1V1"), py::arg("ApproxU2V2"), py::arg("xo"), py::arg("yo"), py::arg("zo"), py::arg("u1o"), py::arg("v1o"), py::arg("u2o"), py::arg("v2o"), py::arg("P2DOnFirst"));
	cls_GeomInt_TheMultiLineOfWLApprox.def(py::init<const opencascade::handle<IntPatch_WLine> &, const Standard_Integer, const Standard_Integer, const Standard_Boolean, const Standard_Boolean, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Boolean, const Standard_Integer>(), py::arg("line"), py::arg("NbP3d"), py::arg("NbP2d"), py::arg("ApproxU1V1"), py::arg("ApproxU2V2"), py::arg("xo"), py::arg("yo"), py::arg("zo"), py::arg("u1o"), py::arg("v1o"), py::arg("u2o"), py::arg("v2o"), py::arg("P2DOnFirst"), py::arg("IndMin"));
	cls_GeomInt_TheMultiLineOfWLApprox.def(py::init<const opencascade::handle<IntPatch_WLine> &, const Standard_Integer, const Standard_Integer, const Standard_Boolean, const Standard_Boolean, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Boolean, const Standard_Integer, const Standard_Integer>(), py::arg("line"), py::arg("NbP3d"), py::arg("NbP2d"), py::arg("ApproxU1V1"), py::arg("ApproxU2V2"), py::arg("xo"), py::arg("yo"), py::arg("zo"), py::arg("u1o"), py::arg("v1o"), py::arg("u2o"), py::arg("v2o"), py::arg("P2DOnFirst"), py::arg("IndMin"), py::arg("IndMax"));
	cls_GeomInt_TheMultiLineOfWLApprox.def("FirstPoint", (Standard_Integer (GeomInt_TheMultiLineOfWLApprox::*)() const ) &GeomInt_TheMultiLineOfWLApprox::FirstPoint, "None");
	cls_GeomInt_TheMultiLineOfWLApprox.def("LastPoint", (Standard_Integer (GeomInt_TheMultiLineOfWLApprox::*)() const ) &GeomInt_TheMultiLineOfWLApprox::LastPoint, "None");
	cls_GeomInt_TheMultiLineOfWLApprox.def("NbP2d", (Standard_Integer (GeomInt_TheMultiLineOfWLApprox::*)() const ) &GeomInt_TheMultiLineOfWLApprox::NbP2d, "Returns the number of 2d points of a TheLine.");
	cls_GeomInt_TheMultiLineOfWLApprox.def("NbP3d", (Standard_Integer (GeomInt_TheMultiLineOfWLApprox::*)() const ) &GeomInt_TheMultiLineOfWLApprox::NbP3d, "Returns the number of 3d points of a TheLine.");
	cls_GeomInt_TheMultiLineOfWLApprox.def("WhatStatus", (Approx_Status (GeomInt_TheMultiLineOfWLApprox::*)() const ) &GeomInt_TheMultiLineOfWLApprox::WhatStatus, "None");
	cls_GeomInt_TheMultiLineOfWLApprox.def("Value", (void (GeomInt_TheMultiLineOfWLApprox::*)(const Standard_Integer, TColgp_Array1OfPnt &) const ) &GeomInt_TheMultiLineOfWLApprox::Value, "Returns the 3d points of the multipoint <MPointIndex> when only 3d points exist.", py::arg("MPointIndex"), py::arg("tabPt"));
	cls_GeomInt_TheMultiLineOfWLApprox.def("Value", (void (GeomInt_TheMultiLineOfWLApprox::*)(const Standard_Integer, TColgp_Array1OfPnt2d &) const ) &GeomInt_TheMultiLineOfWLApprox::Value, "Returns the 2d points of the multipoint <MPointIndex> when only 2d points exist.", py::arg("MPointIndex"), py::arg("tabPt2d"));
	cls_GeomInt_TheMultiLineOfWLApprox.def("Value", (void (GeomInt_TheMultiLineOfWLApprox::*)(const Standard_Integer, TColgp_Array1OfPnt &, TColgp_Array1OfPnt2d &) const ) &GeomInt_TheMultiLineOfWLApprox::Value, "returns the 3d and 2d points of the multipoint <MPointIndex>.", py::arg("MPointIndex"), py::arg("tabPt"), py::arg("tabPt2d"));
	cls_GeomInt_TheMultiLineOfWLApprox.def("Tangency", (Standard_Boolean (GeomInt_TheMultiLineOfWLApprox::*)(const Standard_Integer, TColgp_Array1OfVec &) const ) &GeomInt_TheMultiLineOfWLApprox::Tangency, "Returns the 3d tangency points of the multipoint <MPointIndex> only when 3d points exist.", py::arg("MPointIndex"), py::arg("tabV"));
	cls_GeomInt_TheMultiLineOfWLApprox.def("Tangency", (Standard_Boolean (GeomInt_TheMultiLineOfWLApprox::*)(const Standard_Integer, TColgp_Array1OfVec2d &) const ) &GeomInt_TheMultiLineOfWLApprox::Tangency, "Returns the 2d tangency points of the multipoint <MPointIndex> only when 2d points exist.", py::arg("MPointIndex"), py::arg("tabV2d"));
	cls_GeomInt_TheMultiLineOfWLApprox.def("Tangency", (Standard_Boolean (GeomInt_TheMultiLineOfWLApprox::*)(const Standard_Integer, TColgp_Array1OfVec &, TColgp_Array1OfVec2d &) const ) &GeomInt_TheMultiLineOfWLApprox::Tangency, "Returns the 3d and 2d points of the multipoint <MPointIndex>.", py::arg("MPointIndex"), py::arg("tabV"), py::arg("tabV2d"));
	cls_GeomInt_TheMultiLineOfWLApprox.def("MakeMLBetween", (GeomInt_TheMultiLineOfWLApprox (GeomInt_TheMultiLineOfWLApprox::*)(const Standard_Integer, const Standard_Integer, const Standard_Integer) const ) &GeomInt_TheMultiLineOfWLApprox::MakeMLBetween, "Tries to make a sub-line between <Low> and <High> points of this line by adding <NbPointsToInsert> new points", py::arg("Low"), py::arg("High"), py::arg("NbPointsToInsert"));
	cls_GeomInt_TheMultiLineOfWLApprox.def("MakeMLOneMorePoint", (Standard_Boolean (GeomInt_TheMultiLineOfWLApprox::*)(const Standard_Integer, const Standard_Integer, const Standard_Integer, GeomInt_TheMultiLineOfWLApprox &) const ) &GeomInt_TheMultiLineOfWLApprox::MakeMLOneMorePoint, "Tries to make a sub-line between <Low> and <High> points of this line by adding one more point between (indbad-1)-th and indbad-th points", py::arg("Low"), py::arg("High"), py::arg("indbad"), py::arg("OtherLine"));
	// FIXME cls_GeomInt_TheMultiLineOfWLApprox.def("Dump", (void (GeomInt_TheMultiLineOfWLApprox::*)() const ) &GeomInt_TheMultiLineOfWLApprox::Dump, "Dump of the current multi-line.");

	// C:\Miniconda\envs\occt\Library\include\opencascade\GeomInt_TheMultiLineToolOfWLApprox.hxx
	py::class_<GeomInt_TheMultiLineToolOfWLApprox, std::unique_ptr<GeomInt_TheMultiLineToolOfWLApprox, Deleter<GeomInt_TheMultiLineToolOfWLApprox>>> cls_GeomInt_TheMultiLineToolOfWLApprox(mod, "GeomInt_TheMultiLineToolOfWLApprox", "None");
	cls_GeomInt_TheMultiLineToolOfWLApprox.def(py::init<>());
	cls_GeomInt_TheMultiLineToolOfWLApprox.def_static("FirstPoint_", (Standard_Integer (*)(const GeomInt_TheMultiLineOfWLApprox &)) &GeomInt_TheMultiLineToolOfWLApprox::FirstPoint, "Returns the number of multipoints of the TheMultiLine.", py::arg("ML"));
	cls_GeomInt_TheMultiLineToolOfWLApprox.def_static("LastPoint_", (Standard_Integer (*)(const GeomInt_TheMultiLineOfWLApprox &)) &GeomInt_TheMultiLineToolOfWLApprox::LastPoint, "Returns the number of multipoints of the TheMultiLine.", py::arg("ML"));
	cls_GeomInt_TheMultiLineToolOfWLApprox.def_static("NbP2d_", (Standard_Integer (*)(const GeomInt_TheMultiLineOfWLApprox &)) &GeomInt_TheMultiLineToolOfWLApprox::NbP2d, "Returns the number of 2d points of a TheMultiLine.", py::arg("ML"));
	cls_GeomInt_TheMultiLineToolOfWLApprox.def_static("NbP3d_", (Standard_Integer (*)(const GeomInt_TheMultiLineOfWLApprox &)) &GeomInt_TheMultiLineToolOfWLApprox::NbP3d, "Returns the number of 3d points of a TheMultiLine.", py::arg("ML"));
	cls_GeomInt_TheMultiLineToolOfWLApprox.def_static("Value_", (void (*)(const GeomInt_TheMultiLineOfWLApprox &, const Standard_Integer, TColgp_Array1OfPnt &)) &GeomInt_TheMultiLineToolOfWLApprox::Value, "returns the 3d points of the multipoint <MPointIndex> when only 3d points exist.", py::arg("ML"), py::arg("MPointIndex"), py::arg("tabPt"));
	cls_GeomInt_TheMultiLineToolOfWLApprox.def_static("Value_", (void (*)(const GeomInt_TheMultiLineOfWLApprox &, const Standard_Integer, TColgp_Array1OfPnt2d &)) &GeomInt_TheMultiLineToolOfWLApprox::Value, "returns the 2d points of the multipoint <MPointIndex> when only 2d points exist.", py::arg("ML"), py::arg("MPointIndex"), py::arg("tabPt2d"));
	cls_GeomInt_TheMultiLineToolOfWLApprox.def_static("Value_", (void (*)(const GeomInt_TheMultiLineOfWLApprox &, const Standard_Integer, TColgp_Array1OfPnt &, TColgp_Array1OfPnt2d &)) &GeomInt_TheMultiLineToolOfWLApprox::Value, "returns the 3d and 2d points of the multipoint <MPointIndex>.", py::arg("ML"), py::arg("MPointIndex"), py::arg("tabPt"), py::arg("tabPt2d"));
	cls_GeomInt_TheMultiLineToolOfWLApprox.def_static("Tangency_", (Standard_Boolean (*)(const GeomInt_TheMultiLineOfWLApprox &, const Standard_Integer, TColgp_Array1OfVec &)) &GeomInt_TheMultiLineToolOfWLApprox::Tangency, "returns the 3d points of the multipoint <MPointIndex> when only 3d points exist.", py::arg("ML"), py::arg("MPointIndex"), py::arg("tabV"));
	cls_GeomInt_TheMultiLineToolOfWLApprox.def_static("Tangency_", (Standard_Boolean (*)(const GeomInt_TheMultiLineOfWLApprox &, const Standard_Integer, TColgp_Array1OfVec2d &)) &GeomInt_TheMultiLineToolOfWLApprox::Tangency, "returns the 2d tangency points of the multipoint <MPointIndex> only when 2d points exist.", py::arg("ML"), py::arg("MPointIndex"), py::arg("tabV2d"));
	cls_GeomInt_TheMultiLineToolOfWLApprox.def_static("Tangency_", (Standard_Boolean (*)(const GeomInt_TheMultiLineOfWLApprox &, const Standard_Integer, TColgp_Array1OfVec &, TColgp_Array1OfVec2d &)) &GeomInt_TheMultiLineToolOfWLApprox::Tangency, "returns the 3d and 2d points of the multipoint <MPointIndex>.", py::arg("ML"), py::arg("MPointIndex"), py::arg("tabV"), py::arg("tabV2d"));
	cls_GeomInt_TheMultiLineToolOfWLApprox.def_static("Curvature_", (Standard_Boolean (*)(const GeomInt_TheMultiLineOfWLApprox &, const Standard_Integer, TColgp_Array1OfVec &)) &GeomInt_TheMultiLineToolOfWLApprox::Curvature, "returns the 3d curvature of the multipoint <MPointIndex> when only 3d points exist.", py::arg("ML"), py::arg("MPointIndex"), py::arg("tabV"));
	cls_GeomInt_TheMultiLineToolOfWLApprox.def_static("Curvature_", (Standard_Boolean (*)(const GeomInt_TheMultiLineOfWLApprox &, const Standard_Integer, TColgp_Array1OfVec2d &)) &GeomInt_TheMultiLineToolOfWLApprox::Curvature, "returns the 2d curvature points of the multipoint <MPointIndex> only when 2d points exist.", py::arg("ML"), py::arg("MPointIndex"), py::arg("tabV2d"));
	cls_GeomInt_TheMultiLineToolOfWLApprox.def_static("Curvature_", (Standard_Boolean (*)(const GeomInt_TheMultiLineOfWLApprox &, const Standard_Integer, TColgp_Array1OfVec &, TColgp_Array1OfVec2d &)) &GeomInt_TheMultiLineToolOfWLApprox::Curvature, "returns the 3d and 2d curvature of the multipoint <MPointIndex>.", py::arg("ML"), py::arg("MPointIndex"), py::arg("tabV"), py::arg("tabV2d"));
	cls_GeomInt_TheMultiLineToolOfWLApprox.def_static("MakeMLBetween_", (GeomInt_TheMultiLineOfWLApprox (*)(const GeomInt_TheMultiLineOfWLApprox &, const Standard_Integer, const Standard_Integer, const Standard_Integer)) &GeomInt_TheMultiLineToolOfWLApprox::MakeMLBetween, "Is called if WhatStatus returned 'PointsAdded'.", py::arg("ML"), py::arg("I1"), py::arg("I2"), py::arg("NbPMin"));
	cls_GeomInt_TheMultiLineToolOfWLApprox.def_static("MakeMLOneMorePoint_", (Standard_Boolean (*)(const GeomInt_TheMultiLineOfWLApprox &, const Standard_Integer, const Standard_Integer, const Standard_Integer, GeomInt_TheMultiLineOfWLApprox &)) &GeomInt_TheMultiLineToolOfWLApprox::MakeMLOneMorePoint, "Is called when the Bezier curve contains a loop", py::arg("ML"), py::arg("I1"), py::arg("I2"), py::arg("indbad"), py::arg("OtherLine"));
	cls_GeomInt_TheMultiLineToolOfWLApprox.def_static("WhatStatus_", (Approx_Status (*)(const GeomInt_TheMultiLineOfWLApprox &, const Standard_Integer, const Standard_Integer)) &GeomInt_TheMultiLineToolOfWLApprox::WhatStatus, "None", py::arg("ML"), py::arg("I1"), py::arg("I2"));
	// FIXME cls_GeomInt_TheMultiLineToolOfWLApprox.def_static("Dump_", (void (*)(const GeomInt_TheMultiLineOfWLApprox &)) &GeomInt_TheMultiLineToolOfWLApprox::Dump, "Dump of the current multi-line.", py::arg("ML"));

	// C:\Miniconda\envs\occt\Library\include\opencascade\GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox.hxx
	py::class_<GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox, std::unique_ptr<GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox, Deleter<GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox>>> cls_GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox(mod, "GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox", "None");
	cls_GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox.def(py::init<const GeomInt_TheMultiLineOfWLApprox &, const Standard_Integer, const Standard_Integer, const AppParCurves_Constraint, const AppParCurves_Constraint, const math_Vector &, const Standard_Integer>(), py::arg("SSP"), py::arg("FirstPoint"), py::arg("LastPoint"), py::arg("FirstCons"), py::arg("LastCons"), py::arg("Parameters"), py::arg("NbPol"));
	cls_GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox.def(py::init<const GeomInt_TheMultiLineOfWLApprox &, const Standard_Integer, const Standard_Integer, const AppParCurves_Constraint, const AppParCurves_Constraint, const Standard_Integer>(), py::arg("SSP"), py::arg("FirstPoint"), py::arg("LastPoint"), py::arg("FirstCons"), py::arg("LastCons"), py::arg("NbPol"));
	cls_GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox.def(py::init<const GeomInt_TheMultiLineOfWLApprox &, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger &, const Standard_Integer, const Standard_Integer, const AppParCurves_Constraint, const AppParCurves_Constraint, const math_Vector &, const Standard_Integer>(), py::arg("SSP"), py::arg("Knots"), py::arg("Mults"), py::arg("FirstPoint"), py::arg("LastPoint"), py::arg("FirstCons"), py::arg("LastCons"), py::arg("Parameters"), py::arg("NbPol"));
	cls_GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox.def(py::init<const GeomInt_TheMultiLineOfWLApprox &, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger &, const Standard_Integer, const Standard_Integer, const AppParCurves_Constraint, const AppParCurves_Constraint, const Standard_Integer>(), py::arg("SSP"), py::arg("Knots"), py::arg("Mults"), py::arg("FirstPoint"), py::arg("LastPoint"), py::arg("FirstCons"), py::arg("LastCons"), py::arg("NbPol"));
	cls_GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox.def("Perform", (void (GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox::*)(const math_Vector &)) &GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox::Perform, "Is used after having initialized the fields. The case 'CurvaturePoint' is not treated in this method.", py::arg("Parameters"));
	cls_GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox.def("Perform", (void (GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox::*)(const math_Vector &, const Standard_Real, const Standard_Real)) &GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox::Perform, "Is used after having initialized the fields.", py::arg("Parameters"), py::arg("l1"), py::arg("l2"));
	cls_GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox.def("Perform", (void (GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox::*)(const math_Vector &, const math_Vector &, const math_Vector &, const Standard_Real, const Standard_Real)) &GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox::Perform, "Is used after having initialized the fields. <V1t> is the tangent vector at the first point. <V2t> is the tangent vector at the last point.", py::arg("Parameters"), py::arg("V1t"), py::arg("V2t"), py::arg("l1"), py::arg("l2"));
	cls_GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox.def("Perform", (void (GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox::*)(const math_Vector &, const math_Vector &, const math_Vector &, const math_Vector &, const math_Vector &, const Standard_Real, const Standard_Real)) &GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox::Perform, "Is used after having initialized the fields. <V1t> is the tangent vector at the first point. <V2t> is the tangent vector at the last point. <V1c> is the tangent vector at the first point. <V2c> is the tangent vector at the last point.", py::arg("Parameters"), py::arg("V1t"), py::arg("V2t"), py::arg("V1c"), py::arg("V2c"), py::arg("l1"), py::arg("l2"));
	cls_GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox.def("IsDone", (Standard_Boolean (GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox::*)() const ) &GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox::IsDone, "returns True if all has been correctly done.");
	cls_GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox.def("BezierValue", (AppParCurves_MultiCurve (GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox::*)()) &GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox::BezierValue, "returns the result of the approximation, i.e. all the Curves. An exception is raised if NotDone.");
	cls_GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox.def("BSplineValue", (const AppParCurves_MultiBSpCurve & (GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox::*)()) &GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox::BSplineValue, "returns the result of the approximation, i.e. all the Curves. An exception is raised if NotDone.");
	cls_GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox.def("FunctionMatrix", (const math_Matrix & (GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox::*)() const ) &GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox::FunctionMatrix, "returns the function matrix used to approximate the set.");
	cls_GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox.def("DerivativeFunctionMatrix", (const math_Matrix & (GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox::*)() const ) &GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox::DerivativeFunctionMatrix, "returns the derivative function matrix used to approximate the set.");
	cls_GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox.def("ErrorGradient", [](GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox &self, math_Vector & Grad, Standard_Real & F, Standard_Real & MaxE3d, Standard_Real & MaxE2d){ self.ErrorGradient(Grad, F, MaxE3d, MaxE2d); return std::tuple<Standard_Real &, Standard_Real &, Standard_Real &>(F, MaxE3d, MaxE2d); }, "returns the maximum errors between the MultiLine and the approximation curves. F is the sum of the square distances. Grad is the derivative vector of the function F.", py::arg("Grad"), py::arg("F"), py::arg("MaxE3d"), py::arg("MaxE2d"));
	cls_GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox.def("Distance", (const math_Matrix & (GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox::*)()) &GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox::Distance, "returns the distances between the points of the multiline and the approximation curves.");
	cls_GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox.def("Error", [](GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox &self, Standard_Real & F, Standard_Real & MaxE3d, Standard_Real & MaxE2d){ self.Error(F, MaxE3d, MaxE2d); return std::tuple<Standard_Real &, Standard_Real &, Standard_Real &>(F, MaxE3d, MaxE2d); }, "returns the maximum errors between the MultiLine and the approximation curves. F is the sum of the square distances.", py::arg("F"), py::arg("MaxE3d"), py::arg("MaxE2d"));
	cls_GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox.def("FirstLambda", (Standard_Real (GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox::*)() const ) &GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox::FirstLambda, "returns the value (P2 - P1)/ V1 if the first point was a tangency point.");
	cls_GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox.def("LastLambda", (Standard_Real (GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox::*)() const ) &GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox::LastLambda, "returns the value (PN - PN-1)/ VN if the last point was a tangency point.");
	cls_GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox.def("Points", (const math_Matrix & (GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox::*)() const ) &GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox::Points, "returns the matrix of points value.");
	cls_GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox.def("Poles", (const math_Matrix & (GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox::*)() const ) &GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox::Poles, "returns the matrix of resulting control points value.");
	cls_GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox.def("KIndex", (const math_IntegerVector & (GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox::*)() const ) &GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox::KIndex, "Returns the indexes of the first non null values of A and DA. The values are non null from Index(ieme point) +1 to Index(ieme point) + degree +1.");

	// C:\Miniconda\envs\occt\Library\include\opencascade\GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox.hxx
	py::class_<GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox, std::unique_ptr<GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox, Deleter<GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox>>, math_MultipleVarFunctionWithGradient> cls_GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox(mod, "GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox", "None");
	cls_GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox.def(py::init<const GeomInt_TheMultiLineOfWLApprox &, const Standard_Integer, const Standard_Integer, const opencascade::handle<AppParCurves_HArray1OfConstraintCouple> &, const math_Vector &, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger &, const Standard_Integer>(), py::arg("SSP"), py::arg("FirstPoint"), py::arg("LastPoint"), py::arg("TheConstraints"), py::arg("Parameters"), py::arg("Knots"), py::arg("Mults"), py::arg("NbPol"));
	cls_GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox.def("NbVariables", (Standard_Integer (GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox::*)() const ) &GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox::NbVariables, "returns the number of variables of the function. It corresponds to the number of MultiPoints.");
	cls_GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox.def("Value", [](GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox &self, const math_Vector & X, Standard_Real & F){ Standard_Boolean rv = self.Value(X, F); return std::tuple<Standard_Boolean, Standard_Real &>(rv, F); }, "this method computes the new approximation of the MultiLine SSP and calculates F = sum (||Pui - Bi*Pi||2) for each point of the MultiLine.", py::arg("X"), py::arg("F"));
	cls_GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox.def("Gradient", (Standard_Boolean (GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox::*)(const math_Vector &, math_Vector &)) &GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox::Gradient, "returns the gradient G of the sum above for the parameters Xi.", py::arg("X"), py::arg("G"));
	cls_GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox.def("Values", [](GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox &self, const math_Vector & X, Standard_Real & F, math_Vector & G){ Standard_Boolean rv = self.Values(X, F, G); return std::tuple<Standard_Boolean, Standard_Real &>(rv, F); }, "returns the value F=sum(||Pui - Bi*Pi||)2. returns the value G = grad(F) for the parameters Xi.", py::arg("X"), py::arg("F"), py::arg("G"));
	cls_GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox.def("NewParameters", (const math_Vector & (GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox::*)() const ) &GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox::NewParameters, "returns the new parameters of the MultiLine.");
	cls_GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox.def("CurveValue", (AppParCurves_MultiBSpCurve (GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox::*)()) &GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox::CurveValue, "returns the MultiBSpCurve approximating the set after computing the value F or Grad(F).");
	cls_GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox.def("Error", (Standard_Real (GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox::*)(const Standard_Integer, const Standard_Integer)) &GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox::Error, "returns the distance between the MultiPoint of range IPoint and the curve CurveIndex.", py::arg("IPoint"), py::arg("CurveIndex"));
	cls_GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox.def("MaxError3d", (Standard_Real (GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox::*)() const ) &GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox::MaxError3d, "returns the maximum distance between the points and the MultiBSpCurve.");
	cls_GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox.def("MaxError2d", (Standard_Real (GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox::*)() const ) &GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox::MaxError2d, "returns the maximum distance between the points and the MultiBSpCurve.");
	cls_GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox.def("FunctionMatrix", (const math_Matrix & (GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox::*)() const ) &GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox::FunctionMatrix, "returns the function matrix used to approximate the multiline.");
	cls_GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox.def("DerivativeFunctionMatrix", (const math_Matrix & (GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox::*)() const ) &GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox::DerivativeFunctionMatrix, "returns the derivative function matrix used to approximate the multiline.");
	cls_GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox.def("Index", (const math_IntegerVector & (GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox::*)() const ) &GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox::Index, "Returns the indexes of the first non null values of A and DA. The values are non null from Index(ieme point) +1 to Index(ieme point) + degree +1.");
	cls_GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox.def("FirstConstraint", (AppParCurves_Constraint (GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox::*)(const opencascade::handle<AppParCurves_HArray1OfConstraintCouple> &, const Standard_Integer) const ) &GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox::FirstConstraint, "None", py::arg("TheConstraints"), py::arg("FirstPoint"));
	cls_GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox.def("LastConstraint", (AppParCurves_Constraint (GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox::*)(const opencascade::handle<AppParCurves_HArray1OfConstraintCouple> &, const Standard_Integer) const ) &GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox::LastConstraint, "None", py::arg("TheConstraints"), py::arg("LastPoint"));
	cls_GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox.def("SetFirstLambda", (void (GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox::*)(const Standard_Real)) &GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox::SetFirstLambda, "None", py::arg("l1"));
	cls_GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox.def("SetLastLambda", (void (GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox::*)(const Standard_Real)) &GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox::SetLastLambda, "None", py::arg("l2"));

	// C:\Miniconda\envs\occt\Library\include\opencascade\GeomInt_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfWLApprox.hxx
	py::class_<GeomInt_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfWLApprox, std::unique_ptr<GeomInt_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfWLApprox, Deleter<GeomInt_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfWLApprox>>, math_BFGS> cls_GeomInt_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfWLApprox(mod, "GeomInt_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfWLApprox", "None");
	cls_GeomInt_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfWLApprox.def(py::init<math_MultipleVarFunctionWithGradient &, const math_Vector &, const Standard_Real, const Standard_Real, const Standard_Real>(), py::arg("F"), py::arg("StartingPoint"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("Eps"));
	cls_GeomInt_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfWLApprox.def(py::init<math_MultipleVarFunctionWithGradient &, const math_Vector &, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Integer>(), py::arg("F"), py::arg("StartingPoint"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("Eps"), py::arg("NbIterations"));
	cls_GeomInt_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfWLApprox.def("IsSolutionReached", (Standard_Boolean (GeomInt_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfWLApprox::*)(math_MultipleVarFunctionWithGradient &) const ) &GeomInt_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfWLApprox::IsSolutionReached, "None", py::arg("F"));

	// C:\Miniconda\envs\occt\Library\include\opencascade\GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox.hxx
	py::class_<GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox, std::unique_ptr<GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox, Deleter<GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox>>> cls_GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox(mod, "GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox", "None");
	cls_GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox.def(py::init<const GeomInt_TheMultiLineOfWLApprox &, const Standard_Integer, const Standard_Integer, const opencascade::handle<AppParCurves_HArray1OfConstraintCouple> &, math_Vector &, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger &, const Standard_Integer, const Standard_Real, const Standard_Real>(), py::arg("SSP"), py::arg("FirstPoint"), py::arg("LastPoint"), py::arg("TheConstraints"), py::arg("Parameters"), py::arg("Knots"), py::arg("Mults"), py::arg("Deg"), py::arg("Tol3d"), py::arg("Tol2d"));
	cls_GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox.def(py::init<const GeomInt_TheMultiLineOfWLApprox &, const Standard_Integer, const Standard_Integer, const opencascade::handle<AppParCurves_HArray1OfConstraintCouple> &, math_Vector &, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger &, const Standard_Integer, const Standard_Real, const Standard_Real, const Standard_Integer>(), py::arg("SSP"), py::arg("FirstPoint"), py::arg("LastPoint"), py::arg("TheConstraints"), py::arg("Parameters"), py::arg("Knots"), py::arg("Mults"), py::arg("Deg"), py::arg("Tol3d"), py::arg("Tol2d"), py::arg("NbIterations"));
	cls_GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox.def(py::init<const GeomInt_TheMultiLineOfWLApprox &, const Standard_Integer, const Standard_Integer, const opencascade::handle<AppParCurves_HArray1OfConstraintCouple> &, math_Vector &, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger &, const Standard_Integer, const Standard_Real, const Standard_Real, const Standard_Integer, const Standard_Real, const Standard_Real>(), py::arg("SSP"), py::arg("FirstPoint"), py::arg("LastPoint"), py::arg("TheConstraints"), py::arg("Parameters"), py::arg("Knots"), py::arg("Mults"), py::arg("Deg"), py::arg("Tol3d"), py::arg("Tol2d"), py::arg("NbIterations"), py::arg("lambda1"), py::arg("lambda2"));
	cls_GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox.def("IsDone", (Standard_Boolean (GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox::*)() const ) &GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox::IsDone, "returns True if all has been correctly done.");
	cls_GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox.def("Value", (AppParCurves_MultiBSpCurve (GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox::*)() const ) &GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox::Value, "returns all the BSpline curves approximating the MultiLine SSP after minimization of the parameter.");
	cls_GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox.def("Error", (Standard_Real (GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox::*)(const Standard_Integer) const ) &GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox::Error, "returns the difference between the old and the new approximation. An exception is raised if NotDone. An exception is raised if Index<1 or Index>NbParameters.", py::arg("Index"));
	cls_GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox.def("MaxError3d", (Standard_Real (GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox::*)() const ) &GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox::MaxError3d, "returns the maximum difference between the old and the new approximation.");
	cls_GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox.def("MaxError2d", (Standard_Real (GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox::*)() const ) &GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox::MaxError2d, "returns the maximum difference between the old and the new approximation.");
	cls_GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox.def("AverageError", (Standard_Real (GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox::*)() const ) &GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox::AverageError, "returns the average error between the old and the new approximation.");

	// C:\Miniconda\envs\occt\Library\include\opencascade\GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox.hxx
	py::class_<GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox, std::unique_ptr<GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox, Deleter<GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox>>> cls_GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox(mod, "GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox", "None");
	cls_GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox.def(py::init<const GeomInt_TheMultiLineOfWLApprox &, const Standard_Integer, const Standard_Integer, const AppParCurves_Constraint, const AppParCurves_Constraint, const math_Vector &, const Standard_Integer>(), py::arg("SSP"), py::arg("FirstPoint"), py::arg("LastPoint"), py::arg("FirstCons"), py::arg("LastCons"), py::arg("Parameters"), py::arg("NbPol"));
	cls_GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox.def(py::init<const GeomInt_TheMultiLineOfWLApprox &, const Standard_Integer, const Standard_Integer, const AppParCurves_Constraint, const AppParCurves_Constraint, const Standard_Integer>(), py::arg("SSP"), py::arg("FirstPoint"), py::arg("LastPoint"), py::arg("FirstCons"), py::arg("LastCons"), py::arg("NbPol"));
	cls_GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox.def(py::init<const GeomInt_TheMultiLineOfWLApprox &, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger &, const Standard_Integer, const Standard_Integer, const AppParCurves_Constraint, const AppParCurves_Constraint, const math_Vector &, const Standard_Integer>(), py::arg("SSP"), py::arg("Knots"), py::arg("Mults"), py::arg("FirstPoint"), py::arg("LastPoint"), py::arg("FirstCons"), py::arg("LastCons"), py::arg("Parameters"), py::arg("NbPol"));
	cls_GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox.def(py::init<const GeomInt_TheMultiLineOfWLApprox &, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger &, const Standard_Integer, const Standard_Integer, const AppParCurves_Constraint, const AppParCurves_Constraint, const Standard_Integer>(), py::arg("SSP"), py::arg("Knots"), py::arg("Mults"), py::arg("FirstPoint"), py::arg("LastPoint"), py::arg("FirstCons"), py::arg("LastCons"), py::arg("NbPol"));
	cls_GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox.def("Perform", (void (GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox::*)(const math_Vector &)) &GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox::Perform, "Is used after having initialized the fields. The case 'CurvaturePoint' is not treated in this method.", py::arg("Parameters"));
	cls_GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox.def("Perform", (void (GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox::*)(const math_Vector &, const Standard_Real, const Standard_Real)) &GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox::Perform, "Is used after having initialized the fields.", py::arg("Parameters"), py::arg("l1"), py::arg("l2"));
	cls_GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox.def("Perform", (void (GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox::*)(const math_Vector &, const math_Vector &, const math_Vector &, const Standard_Real, const Standard_Real)) &GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox::Perform, "Is used after having initialized the fields. <V1t> is the tangent vector at the first point. <V2t> is the tangent vector at the last point.", py::arg("Parameters"), py::arg("V1t"), py::arg("V2t"), py::arg("l1"), py::arg("l2"));
	cls_GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox.def("Perform", (void (GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox::*)(const math_Vector &, const math_Vector &, const math_Vector &, const math_Vector &, const math_Vector &, const Standard_Real, const Standard_Real)) &GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox::Perform, "Is used after having initialized the fields. <V1t> is the tangent vector at the first point. <V2t> is the tangent vector at the last point. <V1c> is the tangent vector at the first point. <V2c> is the tangent vector at the last point.", py::arg("Parameters"), py::arg("V1t"), py::arg("V2t"), py::arg("V1c"), py::arg("V2c"), py::arg("l1"), py::arg("l2"));
	cls_GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox.def("IsDone", (Standard_Boolean (GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox::*)() const ) &GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox::IsDone, "returns True if all has been correctly done.");
	cls_GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox.def("BezierValue", (AppParCurves_MultiCurve (GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox::*)()) &GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox::BezierValue, "returns the result of the approximation, i.e. all the Curves. An exception is raised if NotDone.");
	cls_GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox.def("BSplineValue", (const AppParCurves_MultiBSpCurve & (GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox::*)()) &GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox::BSplineValue, "returns the result of the approximation, i.e. all the Curves. An exception is raised if NotDone.");
	cls_GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox.def("FunctionMatrix", (const math_Matrix & (GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox::*)() const ) &GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox::FunctionMatrix, "returns the function matrix used to approximate the set.");
	cls_GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox.def("DerivativeFunctionMatrix", (const math_Matrix & (GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox::*)() const ) &GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox::DerivativeFunctionMatrix, "returns the derivative function matrix used to approximate the set.");
	cls_GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox.def("ErrorGradient", [](GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox &self, math_Vector & Grad, Standard_Real & F, Standard_Real & MaxE3d, Standard_Real & MaxE2d){ self.ErrorGradient(Grad, F, MaxE3d, MaxE2d); return std::tuple<Standard_Real &, Standard_Real &, Standard_Real &>(F, MaxE3d, MaxE2d); }, "returns the maximum errors between the MultiLine and the approximation curves. F is the sum of the square distances. Grad is the derivative vector of the function F.", py::arg("Grad"), py::arg("F"), py::arg("MaxE3d"), py::arg("MaxE2d"));
	cls_GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox.def("Distance", (const math_Matrix & (GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox::*)()) &GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox::Distance, "returns the distances between the points of the multiline and the approximation curves.");
	cls_GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox.def("Error", [](GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox &self, Standard_Real & F, Standard_Real & MaxE3d, Standard_Real & MaxE2d){ self.Error(F, MaxE3d, MaxE2d); return std::tuple<Standard_Real &, Standard_Real &, Standard_Real &>(F, MaxE3d, MaxE2d); }, "returns the maximum errors between the MultiLine and the approximation curves. F is the sum of the square distances.", py::arg("F"), py::arg("MaxE3d"), py::arg("MaxE2d"));
	cls_GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox.def("FirstLambda", (Standard_Real (GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox::*)() const ) &GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox::FirstLambda, "returns the value (P2 - P1)/ V1 if the first point was a tangency point.");
	cls_GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox.def("LastLambda", (Standard_Real (GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox::*)() const ) &GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox::LastLambda, "returns the value (PN - PN-1)/ VN if the last point was a tangency point.");
	cls_GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox.def("Points", (const math_Matrix & (GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox::*)() const ) &GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox::Points, "returns the matrix of points value.");
	cls_GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox.def("Poles", (const math_Matrix & (GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox::*)() const ) &GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox::Poles, "returns the matrix of resulting control points value.");
	cls_GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox.def("KIndex", (const math_IntegerVector & (GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox::*)() const ) &GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox::KIndex, "Returns the indexes of the first non null values of A and DA. The values are non null from Index(ieme point) +1 to Index(ieme point) + degree +1.");

	// C:\Miniconda\envs\occt\Library\include\opencascade\GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox.hxx
	py::class_<GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox, std::unique_ptr<GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox, Deleter<GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox>>> cls_GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox(mod, "GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox", "None");
	cls_GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox.def(py::init<const GeomInt_TheMultiLineOfWLApprox &, AppParCurves_MultiCurve &, const Standard_Integer, const Standard_Integer, const opencascade::handle<AppParCurves_HArray1OfConstraintCouple> &, const math_Matrix &, const math_Matrix &>(), py::arg("SSP"), py::arg("SCurv"), py::arg("FirstPoint"), py::arg("LastPoint"), py::arg("Constraints"), py::arg("Bern"), py::arg("DerivativeBern"));
	cls_GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox.def(py::init<const GeomInt_TheMultiLineOfWLApprox &, AppParCurves_MultiCurve &, const Standard_Integer, const Standard_Integer, const opencascade::handle<AppParCurves_HArray1OfConstraintCouple> &, const math_Matrix &, const math_Matrix &, const Standard_Real>(), py::arg("SSP"), py::arg("SCurv"), py::arg("FirstPoint"), py::arg("LastPoint"), py::arg("Constraints"), py::arg("Bern"), py::arg("DerivativeBern"), py::arg("Tolerance"));
	cls_GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox.def("IsDone", (Standard_Boolean (GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox::*)() const ) &GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox::IsDone, "returns True if all has been correctly done.");
	// cls_GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox.def("Error", (Standard_Real (GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox::*)() const ) &GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox::Error, "returns the maximum difference value between the curve and the given points.");
	cls_GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox.def("ConstraintMatrix", (const math_Matrix & (GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox::*)() const ) &GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox::ConstraintMatrix, "None");
	cls_GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox.def("Duale", (const math_Vector & (GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox::*)() const ) &GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox::Duale, "returns the duale variables of the system.");
	cls_GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox.def("ConstraintDerivative", (const math_Matrix & (GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox::*)(const GeomInt_TheMultiLineOfWLApprox &, const math_Vector &, const Standard_Integer, const math_Matrix &)) &GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox::ConstraintDerivative, "Returns the derivative of the constraint matrix.", py::arg("SSP"), py::arg("Parameters"), py::arg("Deg"), py::arg("DA"));
	cls_GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox.def("InverseMatrix", (const math_Matrix & (GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox::*)() const ) &GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox::InverseMatrix, "returns the Inverse of Cont*Transposed(Cont), where Cont is the constraint matrix for the algorithm.");

	// C:\Miniconda\envs\occt\Library\include\opencascade\GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox.hxx
	py::class_<GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox, std::unique_ptr<GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox, Deleter<GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox>>, math_MultipleVarFunctionWithGradient> cls_GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox(mod, "GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox", "None");
	cls_GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox.def(py::init<const GeomInt_TheMultiLineOfWLApprox &, const Standard_Integer, const Standard_Integer, const opencascade::handle<AppParCurves_HArray1OfConstraintCouple> &, const math_Vector &, const Standard_Integer>(), py::arg("SSP"), py::arg("FirstPoint"), py::arg("LastPoint"), py::arg("TheConstraints"), py::arg("Parameters"), py::arg("Deg"));
	cls_GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox.def("NbVariables", (Standard_Integer (GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox::*)() const ) &GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox::NbVariables, "returns the number of variables of the function. It corresponds to the number of MultiPoints.");
	cls_GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox.def("Value", [](GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox &self, const math_Vector & X, Standard_Real & F){ Standard_Boolean rv = self.Value(X, F); return std::tuple<Standard_Boolean, Standard_Real &>(rv, F); }, "this method computes the new approximation of the MultiLine SSP and calculates F = sum (||Pui - Bi*Pi||2) for each point of the MultiLine.", py::arg("X"), py::arg("F"));
	cls_GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox.def("Gradient", (Standard_Boolean (GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox::*)(const math_Vector &, math_Vector &)) &GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox::Gradient, "returns the gradient G of the sum above for the parameters Xi.", py::arg("X"), py::arg("G"));
	cls_GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox.def("Values", [](GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox &self, const math_Vector & X, Standard_Real & F, math_Vector & G){ Standard_Boolean rv = self.Values(X, F, G); return std::tuple<Standard_Boolean, Standard_Real &>(rv, F); }, "returns the value F=sum(||Pui - Bi*Pi||)2. returns the value G = grad(F) for the parameters Xi.", py::arg("X"), py::arg("F"), py::arg("G"));
	cls_GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox.def("NewParameters", (const math_Vector & (GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox::*)() const ) &GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox::NewParameters, "returns the new parameters of the MultiLine.");
	cls_GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox.def("CurveValue", (const AppParCurves_MultiCurve & (GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox::*)()) &GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox::CurveValue, "returns the MultiCurve approximating the set after computing the value F or Grad(F).");
	cls_GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox.def("Error", (Standard_Real (GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox::*)(const Standard_Integer, const Standard_Integer) const ) &GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox::Error, "returns the distance between the MultiPoint of range IPoint and the curve CurveIndex.", py::arg("IPoint"), py::arg("CurveIndex"));
	cls_GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox.def("MaxError3d", (Standard_Real (GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox::*)() const ) &GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox::MaxError3d, "returns the maximum distance between the points and the MultiCurve.");
	cls_GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox.def("MaxError2d", (Standard_Real (GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox::*)() const ) &GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox::MaxError2d, "returns the maximum distance between the points and the MultiCurve.");
	cls_GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox.def("FirstConstraint", (AppParCurves_Constraint (GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox::*)(const opencascade::handle<AppParCurves_HArray1OfConstraintCouple> &, const Standard_Integer) const ) &GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox::FirstConstraint, "None", py::arg("TheConstraints"), py::arg("FirstPoint"));
	cls_GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox.def("LastConstraint", (AppParCurves_Constraint (GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox::*)(const opencascade::handle<AppParCurves_HArray1OfConstraintCouple> &, const Standard_Integer) const ) &GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox::LastConstraint, "None", py::arg("TheConstraints"), py::arg("LastPoint"));

	// C:\Miniconda\envs\occt\Library\include\opencascade\GeomInt_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfWLApprox.hxx
	py::class_<GeomInt_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfWLApprox, std::unique_ptr<GeomInt_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfWLApprox, Deleter<GeomInt_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfWLApprox>>, math_BFGS> cls_GeomInt_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfWLApprox(mod, "GeomInt_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfWLApprox", "None");
	cls_GeomInt_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfWLApprox.def(py::init<math_MultipleVarFunctionWithGradient &, const math_Vector &, const Standard_Real, const Standard_Real, const Standard_Real>(), py::arg("F"), py::arg("StartingPoint"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("Eps"));
	cls_GeomInt_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfWLApprox.def(py::init<math_MultipleVarFunctionWithGradient &, const math_Vector &, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Integer>(), py::arg("F"), py::arg("StartingPoint"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("Eps"), py::arg("NbIterations"));
	cls_GeomInt_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfWLApprox.def("IsSolutionReached", (Standard_Boolean (GeomInt_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfWLApprox::*)(math_MultipleVarFunctionWithGradient &) const ) &GeomInt_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfWLApprox::IsSolutionReached, "None", py::arg("F"));

	// C:\Miniconda\envs\occt\Library\include\opencascade\GeomInt_MyGradientbisOfTheComputeLineOfWLApprox.hxx
	py::class_<GeomInt_MyGradientbisOfTheComputeLineOfWLApprox, std::unique_ptr<GeomInt_MyGradientbisOfTheComputeLineOfWLApprox, Deleter<GeomInt_MyGradientbisOfTheComputeLineOfWLApprox>>> cls_GeomInt_MyGradientbisOfTheComputeLineOfWLApprox(mod, "GeomInt_MyGradientbisOfTheComputeLineOfWLApprox", "None");
	cls_GeomInt_MyGradientbisOfTheComputeLineOfWLApprox.def(py::init<const GeomInt_TheMultiLineOfWLApprox &, const Standard_Integer, const Standard_Integer, const opencascade::handle<AppParCurves_HArray1OfConstraintCouple> &, math_Vector &, const Standard_Integer, const Standard_Real, const Standard_Real>(), py::arg("SSP"), py::arg("FirstPoint"), py::arg("LastPoint"), py::arg("TheConstraints"), py::arg("Parameters"), py::arg("Deg"), py::arg("Tol3d"), py::arg("Tol2d"));
	cls_GeomInt_MyGradientbisOfTheComputeLineOfWLApprox.def(py::init<const GeomInt_TheMultiLineOfWLApprox &, const Standard_Integer, const Standard_Integer, const opencascade::handle<AppParCurves_HArray1OfConstraintCouple> &, math_Vector &, const Standard_Integer, const Standard_Real, const Standard_Real, const Standard_Integer>(), py::arg("SSP"), py::arg("FirstPoint"), py::arg("LastPoint"), py::arg("TheConstraints"), py::arg("Parameters"), py::arg("Deg"), py::arg("Tol3d"), py::arg("Tol2d"), py::arg("NbIterations"));
	cls_GeomInt_MyGradientbisOfTheComputeLineOfWLApprox.def("IsDone", (Standard_Boolean (GeomInt_MyGradientbisOfTheComputeLineOfWLApprox::*)() const ) &GeomInt_MyGradientbisOfTheComputeLineOfWLApprox::IsDone, "returns True if all has been correctly done.");
	cls_GeomInt_MyGradientbisOfTheComputeLineOfWLApprox.def("Value", (AppParCurves_MultiCurve (GeomInt_MyGradientbisOfTheComputeLineOfWLApprox::*)() const ) &GeomInt_MyGradientbisOfTheComputeLineOfWLApprox::Value, "returns all the Bezier curves approximating the MultiLine SSP after minimization of the parameter.");
	cls_GeomInt_MyGradientbisOfTheComputeLineOfWLApprox.def("Error", (Standard_Real (GeomInt_MyGradientbisOfTheComputeLineOfWLApprox::*)(const Standard_Integer) const ) &GeomInt_MyGradientbisOfTheComputeLineOfWLApprox::Error, "returns the difference between the old and the new approximation. An exception is raised if NotDone. An exception is raised if Index<1 or Index>NbParameters.", py::arg("Index"));
	cls_GeomInt_MyGradientbisOfTheComputeLineOfWLApprox.def("MaxError3d", (Standard_Real (GeomInt_MyGradientbisOfTheComputeLineOfWLApprox::*)() const ) &GeomInt_MyGradientbisOfTheComputeLineOfWLApprox::MaxError3d, "returns the maximum difference between the old and the new approximation.");
	cls_GeomInt_MyGradientbisOfTheComputeLineOfWLApprox.def("MaxError2d", (Standard_Real (GeomInt_MyGradientbisOfTheComputeLineOfWLApprox::*)() const ) &GeomInt_MyGradientbisOfTheComputeLineOfWLApprox::MaxError2d, "returns the maximum difference between the old and the new approximation.");
	cls_GeomInt_MyGradientbisOfTheComputeLineOfWLApprox.def("AverageError", (Standard_Real (GeomInt_MyGradientbisOfTheComputeLineOfWLApprox::*)() const ) &GeomInt_MyGradientbisOfTheComputeLineOfWLApprox::AverageError, "returns the average error between the old and the new approximation.");

	// C:\Miniconda\envs\occt\Library\include\opencascade\GeomInt_TheComputeLineOfWLApprox.hxx
	py::class_<GeomInt_TheComputeLineOfWLApprox, std::unique_ptr<GeomInt_TheComputeLineOfWLApprox, Deleter<GeomInt_TheComputeLineOfWLApprox>>> cls_GeomInt_TheComputeLineOfWLApprox(mod, "GeomInt_TheComputeLineOfWLApprox", "None");
	cls_GeomInt_TheComputeLineOfWLApprox.def(py::init<const GeomInt_TheMultiLineOfWLApprox &>(), py::arg("Line"));
	cls_GeomInt_TheComputeLineOfWLApprox.def(py::init<const GeomInt_TheMultiLineOfWLApprox &, const Standard_Integer>(), py::arg("Line"), py::arg("degreemin"));
	cls_GeomInt_TheComputeLineOfWLApprox.def(py::init<const GeomInt_TheMultiLineOfWLApprox &, const Standard_Integer, const Standard_Integer>(), py::arg("Line"), py::arg("degreemin"), py::arg("degreemax"));
	cls_GeomInt_TheComputeLineOfWLApprox.def(py::init<const GeomInt_TheMultiLineOfWLApprox &, const Standard_Integer, const Standard_Integer, const Standard_Real>(), py::arg("Line"), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"));
	cls_GeomInt_TheComputeLineOfWLApprox.def(py::init<const GeomInt_TheMultiLineOfWLApprox &, const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real>(), py::arg("Line"), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"));
	cls_GeomInt_TheComputeLineOfWLApprox.def(py::init<const GeomInt_TheMultiLineOfWLApprox &, const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real, const Standard_Integer>(), py::arg("Line"), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("NbIterations"));
	cls_GeomInt_TheComputeLineOfWLApprox.def(py::init<const GeomInt_TheMultiLineOfWLApprox &, const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real, const Standard_Integer, const Standard_Boolean>(), py::arg("Line"), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("NbIterations"), py::arg("cutting"));
	cls_GeomInt_TheComputeLineOfWLApprox.def(py::init<const GeomInt_TheMultiLineOfWLApprox &, const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real, const Standard_Integer, const Standard_Boolean, const Approx_ParametrizationType>(), py::arg("Line"), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("NbIterations"), py::arg("cutting"), py::arg("parametrization"));
	cls_GeomInt_TheComputeLineOfWLApprox.def(py::init<const GeomInt_TheMultiLineOfWLApprox &, const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real, const Standard_Integer, const Standard_Boolean, const Approx_ParametrizationType, const Standard_Boolean>(), py::arg("Line"), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("NbIterations"), py::arg("cutting"), py::arg("parametrization"), py::arg("Squares"));
	cls_GeomInt_TheComputeLineOfWLApprox.def(py::init<const GeomInt_TheMultiLineOfWLApprox &, const math_Vector &>(), py::arg("Line"), py::arg("Parameters"));
	cls_GeomInt_TheComputeLineOfWLApprox.def(py::init<const GeomInt_TheMultiLineOfWLApprox &, const math_Vector &, const Standard_Integer>(), py::arg("Line"), py::arg("Parameters"), py::arg("degreemin"));
	cls_GeomInt_TheComputeLineOfWLApprox.def(py::init<const GeomInt_TheMultiLineOfWLApprox &, const math_Vector &, const Standard_Integer, const Standard_Integer>(), py::arg("Line"), py::arg("Parameters"), py::arg("degreemin"), py::arg("degreemax"));
	cls_GeomInt_TheComputeLineOfWLApprox.def(py::init<const GeomInt_TheMultiLineOfWLApprox &, const math_Vector &, const Standard_Integer, const Standard_Integer, const Standard_Real>(), py::arg("Line"), py::arg("Parameters"), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"));
	cls_GeomInt_TheComputeLineOfWLApprox.def(py::init<const GeomInt_TheMultiLineOfWLApprox &, const math_Vector &, const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real>(), py::arg("Line"), py::arg("Parameters"), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"));
	cls_GeomInt_TheComputeLineOfWLApprox.def(py::init<const GeomInt_TheMultiLineOfWLApprox &, const math_Vector &, const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real, const Standard_Integer>(), py::arg("Line"), py::arg("Parameters"), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("NbIterations"));
	cls_GeomInt_TheComputeLineOfWLApprox.def(py::init<const GeomInt_TheMultiLineOfWLApprox &, const math_Vector &, const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real, const Standard_Integer, const Standard_Boolean>(), py::arg("Line"), py::arg("Parameters"), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("NbIterations"), py::arg("cutting"));
	cls_GeomInt_TheComputeLineOfWLApprox.def(py::init<const GeomInt_TheMultiLineOfWLApprox &, const math_Vector &, const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real, const Standard_Integer, const Standard_Boolean, const Standard_Boolean>(), py::arg("Line"), py::arg("Parameters"), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("NbIterations"), py::arg("cutting"), py::arg("Squares"));
	cls_GeomInt_TheComputeLineOfWLApprox.def(py::init<const math_Vector &>(), py::arg("Parameters"));
	cls_GeomInt_TheComputeLineOfWLApprox.def(py::init<const math_Vector &, const Standard_Integer>(), py::arg("Parameters"), py::arg("degreemin"));
	cls_GeomInt_TheComputeLineOfWLApprox.def(py::init<const math_Vector &, const Standard_Integer, const Standard_Integer>(), py::arg("Parameters"), py::arg("degreemin"), py::arg("degreemax"));
	cls_GeomInt_TheComputeLineOfWLApprox.def(py::init<const math_Vector &, const Standard_Integer, const Standard_Integer, const Standard_Real>(), py::arg("Parameters"), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"));
	cls_GeomInt_TheComputeLineOfWLApprox.def(py::init<const math_Vector &, const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real>(), py::arg("Parameters"), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"));
	cls_GeomInt_TheComputeLineOfWLApprox.def(py::init<const math_Vector &, const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real, const Standard_Integer>(), py::arg("Parameters"), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("NbIterations"));
	cls_GeomInt_TheComputeLineOfWLApprox.def(py::init<const math_Vector &, const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real, const Standard_Integer, const Standard_Boolean>(), py::arg("Parameters"), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("NbIterations"), py::arg("cutting"));
	cls_GeomInt_TheComputeLineOfWLApprox.def(py::init<const math_Vector &, const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real, const Standard_Integer, const Standard_Boolean, const Standard_Boolean>(), py::arg("Parameters"), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("NbIterations"), py::arg("cutting"), py::arg("Squares"));
	cls_GeomInt_TheComputeLineOfWLApprox.def(py::init<>());
	cls_GeomInt_TheComputeLineOfWLApprox.def(py::init<const Standard_Integer>(), py::arg("degreemin"));
	cls_GeomInt_TheComputeLineOfWLApprox.def(py::init<const Standard_Integer, const Standard_Integer>(), py::arg("degreemin"), py::arg("degreemax"));
	cls_GeomInt_TheComputeLineOfWLApprox.def(py::init<const Standard_Integer, const Standard_Integer, const Standard_Real>(), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"));
	cls_GeomInt_TheComputeLineOfWLApprox.def(py::init<const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real>(), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"));
	cls_GeomInt_TheComputeLineOfWLApprox.def(py::init<const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real, const Standard_Integer>(), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("NbIterations"));
	cls_GeomInt_TheComputeLineOfWLApprox.def(py::init<const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real, const Standard_Integer, const Standard_Boolean>(), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("NbIterations"), py::arg("cutting"));
	cls_GeomInt_TheComputeLineOfWLApprox.def(py::init<const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real, const Standard_Integer, const Standard_Boolean, const Approx_ParametrizationType>(), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("NbIterations"), py::arg("cutting"), py::arg("parametrization"));
	cls_GeomInt_TheComputeLineOfWLApprox.def(py::init<const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real, const Standard_Integer, const Standard_Boolean, const Approx_ParametrizationType, const Standard_Boolean>(), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("NbIterations"), py::arg("cutting"), py::arg("parametrization"), py::arg("Squares"));
	cls_GeomInt_TheComputeLineOfWLApprox.def("Interpol", (void (GeomInt_TheComputeLineOfWLApprox::*)(const GeomInt_TheMultiLineOfWLApprox &)) &GeomInt_TheComputeLineOfWLApprox::Interpol, "Constructs an interpolation of the MultiLine <Line> The result will be a C2 curve of degree 3.", py::arg("Line"));
	cls_GeomInt_TheComputeLineOfWLApprox.def("Init", [](GeomInt_TheComputeLineOfWLApprox &self) -> void { return self.Init(); });
	cls_GeomInt_TheComputeLineOfWLApprox.def("Init", [](GeomInt_TheComputeLineOfWLApprox &self, const Standard_Integer a0) -> void { return self.Init(a0); }, py::arg("degreemin"));
	cls_GeomInt_TheComputeLineOfWLApprox.def("Init", [](GeomInt_TheComputeLineOfWLApprox &self, const Standard_Integer a0, const Standard_Integer a1) -> void { return self.Init(a0, a1); }, py::arg("degreemin"), py::arg("degreemax"));
	cls_GeomInt_TheComputeLineOfWLApprox.def("Init", [](GeomInt_TheComputeLineOfWLApprox &self, const Standard_Integer a0, const Standard_Integer a1, const Standard_Real a2) -> void { return self.Init(a0, a1, a2); }, py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"));
	cls_GeomInt_TheComputeLineOfWLApprox.def("Init", [](GeomInt_TheComputeLineOfWLApprox &self, const Standard_Integer a0, const Standard_Integer a1, const Standard_Real a2, const Standard_Real a3) -> void { return self.Init(a0, a1, a2, a3); }, py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"));
	cls_GeomInt_TheComputeLineOfWLApprox.def("Init", [](GeomInt_TheComputeLineOfWLApprox &self, const Standard_Integer a0, const Standard_Integer a1, const Standard_Real a2, const Standard_Real a3, const Standard_Integer a4) -> void { return self.Init(a0, a1, a2, a3, a4); }, py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("NbIterations"));
	cls_GeomInt_TheComputeLineOfWLApprox.def("Init", [](GeomInt_TheComputeLineOfWLApprox &self, const Standard_Integer a0, const Standard_Integer a1, const Standard_Real a2, const Standard_Real a3, const Standard_Integer a4, const Standard_Boolean a5) -> void { return self.Init(a0, a1, a2, a3, a4, a5); }, py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("NbIterations"), py::arg("cutting"));
	cls_GeomInt_TheComputeLineOfWLApprox.def("Init", [](GeomInt_TheComputeLineOfWLApprox &self, const Standard_Integer a0, const Standard_Integer a1, const Standard_Real a2, const Standard_Real a3, const Standard_Integer a4, const Standard_Boolean a5, const Approx_ParametrizationType a6) -> void { return self.Init(a0, a1, a2, a3, a4, a5, a6); }, py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("NbIterations"), py::arg("cutting"), py::arg("parametrization"));
	cls_GeomInt_TheComputeLineOfWLApprox.def("Init", (void (GeomInt_TheComputeLineOfWLApprox::*)(const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real, const Standard_Integer, const Standard_Boolean, const Approx_ParametrizationType, const Standard_Boolean)) &GeomInt_TheComputeLineOfWLApprox::Init, "Initializes the fields of the algorithm.", py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("NbIterations"), py::arg("cutting"), py::arg("parametrization"), py::arg("Squares"));
	cls_GeomInt_TheComputeLineOfWLApprox.def("Perform", (void (GeomInt_TheComputeLineOfWLApprox::*)(const GeomInt_TheMultiLineOfWLApprox &)) &GeomInt_TheComputeLineOfWLApprox::Perform, "runs the algorithm after having initialized the fields.", py::arg("Line"));
	cls_GeomInt_TheComputeLineOfWLApprox.def("SetParameters", (void (GeomInt_TheComputeLineOfWLApprox::*)(const math_Vector &)) &GeomInt_TheComputeLineOfWLApprox::SetParameters, "The approximation will begin with the set of parameters <ThePar>.", py::arg("ThePar"));
	cls_GeomInt_TheComputeLineOfWLApprox.def("SetKnots", (void (GeomInt_TheComputeLineOfWLApprox::*)(const TColStd_Array1OfReal &)) &GeomInt_TheComputeLineOfWLApprox::SetKnots, "The approximation will be done with the set of knots <Knots>. The multiplicities will be set with the degree and the desired continuity.", py::arg("Knots"));
	cls_GeomInt_TheComputeLineOfWLApprox.def("SetKnotsAndMultiplicities", (void (GeomInt_TheComputeLineOfWLApprox::*)(const TColStd_Array1OfReal &, const TColStd_Array1OfInteger &)) &GeomInt_TheComputeLineOfWLApprox::SetKnotsAndMultiplicities, "The approximation will be done with the set of knots <Knots> and the multiplicities <Mults>.", py::arg("Knots"), py::arg("Mults"));
	cls_GeomInt_TheComputeLineOfWLApprox.def("SetDegrees", (void (GeomInt_TheComputeLineOfWLApprox::*)(const Standard_Integer, const Standard_Integer)) &GeomInt_TheComputeLineOfWLApprox::SetDegrees, "changes the degrees of the approximation.", py::arg("degreemin"), py::arg("degreemax"));
	cls_GeomInt_TheComputeLineOfWLApprox.def("SetTolerances", (void (GeomInt_TheComputeLineOfWLApprox::*)(const Standard_Real, const Standard_Real)) &GeomInt_TheComputeLineOfWLApprox::SetTolerances, "Changes the tolerances of the approximation.", py::arg("Tolerance3d"), py::arg("Tolerance2d"));
	cls_GeomInt_TheComputeLineOfWLApprox.def("SetContinuity", (void (GeomInt_TheComputeLineOfWLApprox::*)(const Standard_Integer)) &GeomInt_TheComputeLineOfWLApprox::SetContinuity, "sets the continuity of the spline. if C = 2, the spline will be C2.", py::arg("C"));
	cls_GeomInt_TheComputeLineOfWLApprox.def("SetConstraints", (void (GeomInt_TheComputeLineOfWLApprox::*)(const AppParCurves_Constraint, const AppParCurves_Constraint)) &GeomInt_TheComputeLineOfWLApprox::SetConstraints, "changes the first and the last constraint points.", py::arg("firstC"), py::arg("lastC"));
	cls_GeomInt_TheComputeLineOfWLApprox.def("IsAllApproximated", (Standard_Boolean (GeomInt_TheComputeLineOfWLApprox::*)() const ) &GeomInt_TheComputeLineOfWLApprox::IsAllApproximated, "returns False if at a moment of the approximation, the status NoApproximation has been sent by the user when more points were needed.");
	cls_GeomInt_TheComputeLineOfWLApprox.def("IsToleranceReached", (Standard_Boolean (GeomInt_TheComputeLineOfWLApprox::*)() const ) &GeomInt_TheComputeLineOfWLApprox::IsToleranceReached, "returns False if the status NoPointsAdded has been sent.");
	cls_GeomInt_TheComputeLineOfWLApprox.def("Error", [](GeomInt_TheComputeLineOfWLApprox &self, Standard_Real & tol3d, Standard_Real & tol2d){ self.Error(tol3d, tol2d); return std::tuple<Standard_Real &, Standard_Real &>(tol3d, tol2d); }, "returns the tolerances 2d and 3d of the MultiBSpCurve.", py::arg("tol3d"), py::arg("tol2d"));
	cls_GeomInt_TheComputeLineOfWLApprox.def("Value", (const AppParCurves_MultiBSpCurve & (GeomInt_TheComputeLineOfWLApprox::*)() const ) &GeomInt_TheComputeLineOfWLApprox::Value, "returns the result of the approximation.");
	cls_GeomInt_TheComputeLineOfWLApprox.def("ChangeValue", (AppParCurves_MultiBSpCurve & (GeomInt_TheComputeLineOfWLApprox::*)()) &GeomInt_TheComputeLineOfWLApprox::ChangeValue, "returns the result of the approximation.");
	cls_GeomInt_TheComputeLineOfWLApprox.def("Parameters", (const TColStd_Array1OfReal & (GeomInt_TheComputeLineOfWLApprox::*)() const ) &GeomInt_TheComputeLineOfWLApprox::Parameters, "returns the new parameters of the approximation corresponding to the points of the MultiBSpCurve.");

	// C:\Miniconda\envs\occt\Library\include\opencascade\GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox.hxx
	py::class_<GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox, std::unique_ptr<GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox, Deleter<GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox>>> cls_GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox(mod, "GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox", "None");
	cls_GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox.def(py::init<const GeomInt_TheMultiLineOfWLApprox &, const Standard_Integer, const Standard_Integer, const AppParCurves_Constraint, const AppParCurves_Constraint, const math_Vector &, const Standard_Integer>(), py::arg("SSP"), py::arg("FirstPoint"), py::arg("LastPoint"), py::arg("FirstCons"), py::arg("LastCons"), py::arg("Parameters"), py::arg("NbPol"));
	cls_GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox.def(py::init<const GeomInt_TheMultiLineOfWLApprox &, const Standard_Integer, const Standard_Integer, const AppParCurves_Constraint, const AppParCurves_Constraint, const Standard_Integer>(), py::arg("SSP"), py::arg("FirstPoint"), py::arg("LastPoint"), py::arg("FirstCons"), py::arg("LastCons"), py::arg("NbPol"));
	cls_GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox.def(py::init<const GeomInt_TheMultiLineOfWLApprox &, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger &, const Standard_Integer, const Standard_Integer, const AppParCurves_Constraint, const AppParCurves_Constraint, const math_Vector &, const Standard_Integer>(), py::arg("SSP"), py::arg("Knots"), py::arg("Mults"), py::arg("FirstPoint"), py::arg("LastPoint"), py::arg("FirstCons"), py::arg("LastCons"), py::arg("Parameters"), py::arg("NbPol"));
	cls_GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox.def(py::init<const GeomInt_TheMultiLineOfWLApprox &, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger &, const Standard_Integer, const Standard_Integer, const AppParCurves_Constraint, const AppParCurves_Constraint, const Standard_Integer>(), py::arg("SSP"), py::arg("Knots"), py::arg("Mults"), py::arg("FirstPoint"), py::arg("LastPoint"), py::arg("FirstCons"), py::arg("LastCons"), py::arg("NbPol"));
	cls_GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox.def("Perform", (void (GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox::*)(const math_Vector &)) &GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox::Perform, "Is used after having initialized the fields. The case 'CurvaturePoint' is not treated in this method.", py::arg("Parameters"));
	cls_GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox.def("Perform", (void (GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox::*)(const math_Vector &, const Standard_Real, const Standard_Real)) &GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox::Perform, "Is used after having initialized the fields.", py::arg("Parameters"), py::arg("l1"), py::arg("l2"));
	cls_GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox.def("Perform", (void (GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox::*)(const math_Vector &, const math_Vector &, const math_Vector &, const Standard_Real, const Standard_Real)) &GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox::Perform, "Is used after having initialized the fields. <V1t> is the tangent vector at the first point. <V2t> is the tangent vector at the last point.", py::arg("Parameters"), py::arg("V1t"), py::arg("V2t"), py::arg("l1"), py::arg("l2"));
	cls_GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox.def("Perform", (void (GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox::*)(const math_Vector &, const math_Vector &, const math_Vector &, const math_Vector &, const math_Vector &, const Standard_Real, const Standard_Real)) &GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox::Perform, "Is used after having initialized the fields. <V1t> is the tangent vector at the first point. <V2t> is the tangent vector at the last point. <V1c> is the tangent vector at the first point. <V2c> is the tangent vector at the last point.", py::arg("Parameters"), py::arg("V1t"), py::arg("V2t"), py::arg("V1c"), py::arg("V2c"), py::arg("l1"), py::arg("l2"));
	cls_GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox.def("IsDone", (Standard_Boolean (GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox::*)() const ) &GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox::IsDone, "returns True if all has been correctly done.");
	cls_GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox.def("BezierValue", (AppParCurves_MultiCurve (GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox::*)()) &GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox::BezierValue, "returns the result of the approximation, i.e. all the Curves. An exception is raised if NotDone.");
	cls_GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox.def("BSplineValue", (const AppParCurves_MultiBSpCurve & (GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox::*)()) &GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox::BSplineValue, "returns the result of the approximation, i.e. all the Curves. An exception is raised if NotDone.");
	cls_GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox.def("FunctionMatrix", (const math_Matrix & (GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox::*)() const ) &GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox::FunctionMatrix, "returns the function matrix used to approximate the set.");
	cls_GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox.def("DerivativeFunctionMatrix", (const math_Matrix & (GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox::*)() const ) &GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox::DerivativeFunctionMatrix, "returns the derivative function matrix used to approximate the set.");
	cls_GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox.def("ErrorGradient", [](GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox &self, math_Vector & Grad, Standard_Real & F, Standard_Real & MaxE3d, Standard_Real & MaxE2d){ self.ErrorGradient(Grad, F, MaxE3d, MaxE2d); return std::tuple<Standard_Real &, Standard_Real &, Standard_Real &>(F, MaxE3d, MaxE2d); }, "returns the maximum errors between the MultiLine and the approximation curves. F is the sum of the square distances. Grad is the derivative vector of the function F.", py::arg("Grad"), py::arg("F"), py::arg("MaxE3d"), py::arg("MaxE2d"));
	cls_GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox.def("Distance", (const math_Matrix & (GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox::*)()) &GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox::Distance, "returns the distances between the points of the multiline and the approximation curves.");
	cls_GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox.def("Error", [](GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox &self, Standard_Real & F, Standard_Real & MaxE3d, Standard_Real & MaxE2d){ self.Error(F, MaxE3d, MaxE2d); return std::tuple<Standard_Real &, Standard_Real &, Standard_Real &>(F, MaxE3d, MaxE2d); }, "returns the maximum errors between the MultiLine and the approximation curves. F is the sum of the square distances.", py::arg("F"), py::arg("MaxE3d"), py::arg("MaxE2d"));
	cls_GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox.def("FirstLambda", (Standard_Real (GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox::*)() const ) &GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox::FirstLambda, "returns the value (P2 - P1)/ V1 if the first point was a tangency point.");
	cls_GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox.def("LastLambda", (Standard_Real (GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox::*)() const ) &GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox::LastLambda, "returns the value (PN - PN-1)/ VN if the last point was a tangency point.");
	cls_GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox.def("Points", (const math_Matrix & (GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox::*)() const ) &GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox::Points, "returns the matrix of points value.");
	cls_GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox.def("Poles", (const math_Matrix & (GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox::*)() const ) &GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox::Poles, "returns the matrix of resulting control points value.");
	cls_GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox.def("KIndex", (const math_IntegerVector & (GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox::*)() const ) &GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox::KIndex, "Returns the indexes of the first non null values of A and DA. The values are non null from Index(ieme point) +1 to Index(ieme point) + degree +1.");

	// C:\Miniconda\envs\occt\Library\include\opencascade\GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox.hxx
	py::class_<GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox, std::unique_ptr<GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox, Deleter<GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox>>> cls_GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox(mod, "GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox", "None");
	cls_GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox.def(py::init<const GeomInt_TheMultiLineOfWLApprox &, AppParCurves_MultiCurve &, const Standard_Integer, const Standard_Integer, const opencascade::handle<AppParCurves_HArray1OfConstraintCouple> &, const math_Matrix &, const math_Matrix &>(), py::arg("SSP"), py::arg("SCurv"), py::arg("FirstPoint"), py::arg("LastPoint"), py::arg("Constraints"), py::arg("Bern"), py::arg("DerivativeBern"));
	cls_GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox.def(py::init<const GeomInt_TheMultiLineOfWLApprox &, AppParCurves_MultiCurve &, const Standard_Integer, const Standard_Integer, const opencascade::handle<AppParCurves_HArray1OfConstraintCouple> &, const math_Matrix &, const math_Matrix &, const Standard_Real>(), py::arg("SSP"), py::arg("SCurv"), py::arg("FirstPoint"), py::arg("LastPoint"), py::arg("Constraints"), py::arg("Bern"), py::arg("DerivativeBern"), py::arg("Tolerance"));
	cls_GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox.def("IsDone", (Standard_Boolean (GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox::*)() const ) &GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox::IsDone, "returns True if all has been correctly done.");
	// cls_GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox.def("Error", (Standard_Real (GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox::*)() const ) &GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox::Error, "returns the maximum difference value between the curve and the given points.");
	cls_GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox.def("ConstraintMatrix", (const math_Matrix & (GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox::*)() const ) &GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox::ConstraintMatrix, "None");
	cls_GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox.def("Duale", (const math_Vector & (GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox::*)() const ) &GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox::Duale, "returns the duale variables of the system.");
	cls_GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox.def("ConstraintDerivative", (const math_Matrix & (GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox::*)(const GeomInt_TheMultiLineOfWLApprox &, const math_Vector &, const Standard_Integer, const math_Matrix &)) &GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox::ConstraintDerivative, "Returns the derivative of the constraint matrix.", py::arg("SSP"), py::arg("Parameters"), py::arg("Deg"), py::arg("DA"));
	cls_GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox.def("InverseMatrix", (const math_Matrix & (GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox::*)() const ) &GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox::InverseMatrix, "returns the Inverse of Cont*Transposed(Cont), where Cont is the constraint matrix for the algorithm.");

	// C:\Miniconda\envs\occt\Library\include\opencascade\GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox.hxx
	py::class_<GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox, std::unique_ptr<GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox, Deleter<GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox>>, math_MultipleVarFunctionWithGradient> cls_GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox(mod, "GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox", "None");
	cls_GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox.def(py::init<const GeomInt_TheMultiLineOfWLApprox &, const Standard_Integer, const Standard_Integer, const opencascade::handle<AppParCurves_HArray1OfConstraintCouple> &, const math_Vector &, const Standard_Integer>(), py::arg("SSP"), py::arg("FirstPoint"), py::arg("LastPoint"), py::arg("TheConstraints"), py::arg("Parameters"), py::arg("Deg"));
	cls_GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox.def("NbVariables", (Standard_Integer (GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox::*)() const ) &GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox::NbVariables, "returns the number of variables of the function. It corresponds to the number of MultiPoints.");
	cls_GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox.def("Value", [](GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox &self, const math_Vector & X, Standard_Real & F){ Standard_Boolean rv = self.Value(X, F); return std::tuple<Standard_Boolean, Standard_Real &>(rv, F); }, "this method computes the new approximation of the MultiLine SSP and calculates F = sum (||Pui - Bi*Pi||2) for each point of the MultiLine.", py::arg("X"), py::arg("F"));
	cls_GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox.def("Gradient", (Standard_Boolean (GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox::*)(const math_Vector &, math_Vector &)) &GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox::Gradient, "returns the gradient G of the sum above for the parameters Xi.", py::arg("X"), py::arg("G"));
	cls_GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox.def("Values", [](GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox &self, const math_Vector & X, Standard_Real & F, math_Vector & G){ Standard_Boolean rv = self.Values(X, F, G); return std::tuple<Standard_Boolean, Standard_Real &>(rv, F); }, "returns the value F=sum(||Pui - Bi*Pi||)2. returns the value G = grad(F) for the parameters Xi.", py::arg("X"), py::arg("F"), py::arg("G"));
	cls_GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox.def("NewParameters", (const math_Vector & (GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox::*)() const ) &GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox::NewParameters, "returns the new parameters of the MultiLine.");
	cls_GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox.def("CurveValue", (const AppParCurves_MultiCurve & (GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox::*)()) &GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox::CurveValue, "returns the MultiCurve approximating the set after computing the value F or Grad(F).");
	cls_GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox.def("Error", (Standard_Real (GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox::*)(const Standard_Integer, const Standard_Integer) const ) &GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox::Error, "returns the distance between the MultiPoint of range IPoint and the curve CurveIndex.", py::arg("IPoint"), py::arg("CurveIndex"));
	cls_GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox.def("MaxError3d", (Standard_Real (GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox::*)() const ) &GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox::MaxError3d, "returns the maximum distance between the points and the MultiCurve.");
	cls_GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox.def("MaxError2d", (Standard_Real (GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox::*)() const ) &GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox::MaxError2d, "returns the maximum distance between the points and the MultiCurve.");
	cls_GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox.def("FirstConstraint", (AppParCurves_Constraint (GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox::*)(const opencascade::handle<AppParCurves_HArray1OfConstraintCouple> &, const Standard_Integer) const ) &GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox::FirstConstraint, "None", py::arg("TheConstraints"), py::arg("FirstPoint"));
	cls_GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox.def("LastConstraint", (AppParCurves_Constraint (GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox::*)(const opencascade::handle<AppParCurves_HArray1OfConstraintCouple> &, const Standard_Integer) const ) &GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox::LastConstraint, "None", py::arg("TheConstraints"), py::arg("LastPoint"));

	// C:\Miniconda\envs\occt\Library\include\opencascade\GeomInt_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfWLApprox.hxx
	py::class_<GeomInt_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfWLApprox, std::unique_ptr<GeomInt_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfWLApprox, Deleter<GeomInt_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfWLApprox>>, math_BFGS> cls_GeomInt_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfWLApprox(mod, "GeomInt_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfWLApprox", "None");
	cls_GeomInt_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfWLApprox.def(py::init<math_MultipleVarFunctionWithGradient &, const math_Vector &, const Standard_Real, const Standard_Real, const Standard_Real>(), py::arg("F"), py::arg("StartingPoint"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("Eps"));
	cls_GeomInt_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfWLApprox.def(py::init<math_MultipleVarFunctionWithGradient &, const math_Vector &, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Integer>(), py::arg("F"), py::arg("StartingPoint"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("Eps"), py::arg("NbIterations"));
	cls_GeomInt_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfWLApprox.def("IsSolutionReached", (Standard_Boolean (GeomInt_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfWLApprox::*)(math_MultipleVarFunctionWithGradient &) const ) &GeomInt_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfWLApprox::IsSolutionReached, "None", py::arg("F"));

	// C:\Miniconda\envs\occt\Library\include\opencascade\GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox.hxx
	py::class_<GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox, std::unique_ptr<GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox, Deleter<GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox>>> cls_GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox(mod, "GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox", "None");
	cls_GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox.def(py::init<const GeomInt_TheMultiLineOfWLApprox &, const Standard_Integer, const Standard_Integer, const opencascade::handle<AppParCurves_HArray1OfConstraintCouple> &, math_Vector &, const Standard_Integer, const Standard_Real, const Standard_Real>(), py::arg("SSP"), py::arg("FirstPoint"), py::arg("LastPoint"), py::arg("TheConstraints"), py::arg("Parameters"), py::arg("Deg"), py::arg("Tol3d"), py::arg("Tol2d"));
	cls_GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox.def(py::init<const GeomInt_TheMultiLineOfWLApprox &, const Standard_Integer, const Standard_Integer, const opencascade::handle<AppParCurves_HArray1OfConstraintCouple> &, math_Vector &, const Standard_Integer, const Standard_Real, const Standard_Real, const Standard_Integer>(), py::arg("SSP"), py::arg("FirstPoint"), py::arg("LastPoint"), py::arg("TheConstraints"), py::arg("Parameters"), py::arg("Deg"), py::arg("Tol3d"), py::arg("Tol2d"), py::arg("NbIterations"));
	cls_GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox.def("IsDone", (Standard_Boolean (GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox::*)() const ) &GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox::IsDone, "returns True if all has been correctly done.");
	cls_GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox.def("Value", (AppParCurves_MultiCurve (GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox::*)() const ) &GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox::Value, "returns all the Bezier curves approximating the MultiLine SSP after minimization of the parameter.");
	cls_GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox.def("Error", (Standard_Real (GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox::*)(const Standard_Integer) const ) &GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox::Error, "returns the difference between the old and the new approximation. An exception is raised if NotDone. An exception is raised if Index<1 or Index>NbParameters.", py::arg("Index"));
	cls_GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox.def("MaxError3d", (Standard_Real (GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox::*)() const ) &GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox::MaxError3d, "returns the maximum difference between the old and the new approximation.");
	cls_GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox.def("MaxError2d", (Standard_Real (GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox::*)() const ) &GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox::MaxError2d, "returns the maximum difference between the old and the new approximation.");
	cls_GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox.def("AverageError", (Standard_Real (GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox::*)() const ) &GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox::AverageError, "returns the average error between the old and the new approximation.");

	// C:\Miniconda\envs\occt\Library\include\opencascade\GeomInt_TheComputeLineBezierOfWLApprox.hxx
	py::class_<GeomInt_TheComputeLineBezierOfWLApprox, std::unique_ptr<GeomInt_TheComputeLineBezierOfWLApprox, Deleter<GeomInt_TheComputeLineBezierOfWLApprox>>> cls_GeomInt_TheComputeLineBezierOfWLApprox(mod, "GeomInt_TheComputeLineBezierOfWLApprox", "None");
	cls_GeomInt_TheComputeLineBezierOfWLApprox.def(py::init<const GeomInt_TheMultiLineOfWLApprox &>(), py::arg("Line"));
	cls_GeomInt_TheComputeLineBezierOfWLApprox.def(py::init<const GeomInt_TheMultiLineOfWLApprox &, const Standard_Integer>(), py::arg("Line"), py::arg("degreemin"));
	cls_GeomInt_TheComputeLineBezierOfWLApprox.def(py::init<const GeomInt_TheMultiLineOfWLApprox &, const Standard_Integer, const Standard_Integer>(), py::arg("Line"), py::arg("degreemin"), py::arg("degreemax"));
	cls_GeomInt_TheComputeLineBezierOfWLApprox.def(py::init<const GeomInt_TheMultiLineOfWLApprox &, const Standard_Integer, const Standard_Integer, const Standard_Real>(), py::arg("Line"), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"));
	cls_GeomInt_TheComputeLineBezierOfWLApprox.def(py::init<const GeomInt_TheMultiLineOfWLApprox &, const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real>(), py::arg("Line"), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"));
	cls_GeomInt_TheComputeLineBezierOfWLApprox.def(py::init<const GeomInt_TheMultiLineOfWLApprox &, const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real, const Standard_Integer>(), py::arg("Line"), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("NbIterations"));
	cls_GeomInt_TheComputeLineBezierOfWLApprox.def(py::init<const GeomInt_TheMultiLineOfWLApprox &, const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real, const Standard_Integer, const Standard_Boolean>(), py::arg("Line"), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("NbIterations"), py::arg("cutting"));
	cls_GeomInt_TheComputeLineBezierOfWLApprox.def(py::init<const GeomInt_TheMultiLineOfWLApprox &, const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real, const Standard_Integer, const Standard_Boolean, const Approx_ParametrizationType>(), py::arg("Line"), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("NbIterations"), py::arg("cutting"), py::arg("parametrization"));
	cls_GeomInt_TheComputeLineBezierOfWLApprox.def(py::init<const GeomInt_TheMultiLineOfWLApprox &, const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real, const Standard_Integer, const Standard_Boolean, const Approx_ParametrizationType, const Standard_Boolean>(), py::arg("Line"), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("NbIterations"), py::arg("cutting"), py::arg("parametrization"), py::arg("Squares"));
	cls_GeomInt_TheComputeLineBezierOfWLApprox.def(py::init<const GeomInt_TheMultiLineOfWLApprox &, const math_Vector &>(), py::arg("Line"), py::arg("Parameters"));
	cls_GeomInt_TheComputeLineBezierOfWLApprox.def(py::init<const GeomInt_TheMultiLineOfWLApprox &, const math_Vector &, const Standard_Integer>(), py::arg("Line"), py::arg("Parameters"), py::arg("degreemin"));
	cls_GeomInt_TheComputeLineBezierOfWLApprox.def(py::init<const GeomInt_TheMultiLineOfWLApprox &, const math_Vector &, const Standard_Integer, const Standard_Integer>(), py::arg("Line"), py::arg("Parameters"), py::arg("degreemin"), py::arg("degreemax"));
	cls_GeomInt_TheComputeLineBezierOfWLApprox.def(py::init<const GeomInt_TheMultiLineOfWLApprox &, const math_Vector &, const Standard_Integer, const Standard_Integer, const Standard_Real>(), py::arg("Line"), py::arg("Parameters"), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"));
	cls_GeomInt_TheComputeLineBezierOfWLApprox.def(py::init<const GeomInt_TheMultiLineOfWLApprox &, const math_Vector &, const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real>(), py::arg("Line"), py::arg("Parameters"), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"));
	cls_GeomInt_TheComputeLineBezierOfWLApprox.def(py::init<const GeomInt_TheMultiLineOfWLApprox &, const math_Vector &, const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real, const Standard_Integer>(), py::arg("Line"), py::arg("Parameters"), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("NbIterations"));
	cls_GeomInt_TheComputeLineBezierOfWLApprox.def(py::init<const GeomInt_TheMultiLineOfWLApprox &, const math_Vector &, const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real, const Standard_Integer, const Standard_Boolean>(), py::arg("Line"), py::arg("Parameters"), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("NbIterations"), py::arg("cutting"));
	cls_GeomInt_TheComputeLineBezierOfWLApprox.def(py::init<const GeomInt_TheMultiLineOfWLApprox &, const math_Vector &, const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real, const Standard_Integer, const Standard_Boolean, const Standard_Boolean>(), py::arg("Line"), py::arg("Parameters"), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("NbIterations"), py::arg("cutting"), py::arg("Squares"));
	cls_GeomInt_TheComputeLineBezierOfWLApprox.def(py::init<const math_Vector &>(), py::arg("Parameters"));
	cls_GeomInt_TheComputeLineBezierOfWLApprox.def(py::init<const math_Vector &, const Standard_Integer>(), py::arg("Parameters"), py::arg("degreemin"));
	cls_GeomInt_TheComputeLineBezierOfWLApprox.def(py::init<const math_Vector &, const Standard_Integer, const Standard_Integer>(), py::arg("Parameters"), py::arg("degreemin"), py::arg("degreemax"));
	cls_GeomInt_TheComputeLineBezierOfWLApprox.def(py::init<const math_Vector &, const Standard_Integer, const Standard_Integer, const Standard_Real>(), py::arg("Parameters"), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"));
	cls_GeomInt_TheComputeLineBezierOfWLApprox.def(py::init<const math_Vector &, const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real>(), py::arg("Parameters"), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"));
	cls_GeomInt_TheComputeLineBezierOfWLApprox.def(py::init<const math_Vector &, const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real, const Standard_Integer>(), py::arg("Parameters"), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("NbIterations"));
	cls_GeomInt_TheComputeLineBezierOfWLApprox.def(py::init<const math_Vector &, const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real, const Standard_Integer, const Standard_Boolean>(), py::arg("Parameters"), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("NbIterations"), py::arg("cutting"));
	cls_GeomInt_TheComputeLineBezierOfWLApprox.def(py::init<const math_Vector &, const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real, const Standard_Integer, const Standard_Boolean, const Standard_Boolean>(), py::arg("Parameters"), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("NbIterations"), py::arg("cutting"), py::arg("Squares"));
	cls_GeomInt_TheComputeLineBezierOfWLApprox.def(py::init<>());
	cls_GeomInt_TheComputeLineBezierOfWLApprox.def(py::init<const Standard_Integer>(), py::arg("degreemin"));
	cls_GeomInt_TheComputeLineBezierOfWLApprox.def(py::init<const Standard_Integer, const Standard_Integer>(), py::arg("degreemin"), py::arg("degreemax"));
	cls_GeomInt_TheComputeLineBezierOfWLApprox.def(py::init<const Standard_Integer, const Standard_Integer, const Standard_Real>(), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"));
	cls_GeomInt_TheComputeLineBezierOfWLApprox.def(py::init<const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real>(), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"));
	cls_GeomInt_TheComputeLineBezierOfWLApprox.def(py::init<const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real, const Standard_Integer>(), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("NbIterations"));
	cls_GeomInt_TheComputeLineBezierOfWLApprox.def(py::init<const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real, const Standard_Integer, const Standard_Boolean>(), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("NbIterations"), py::arg("cutting"));
	cls_GeomInt_TheComputeLineBezierOfWLApprox.def(py::init<const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real, const Standard_Integer, const Standard_Boolean, const Approx_ParametrizationType>(), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("NbIterations"), py::arg("cutting"), py::arg("parametrization"));
	cls_GeomInt_TheComputeLineBezierOfWLApprox.def(py::init<const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real, const Standard_Integer, const Standard_Boolean, const Approx_ParametrizationType, const Standard_Boolean>(), py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("NbIterations"), py::arg("cutting"), py::arg("parametrization"), py::arg("Squares"));
	cls_GeomInt_TheComputeLineBezierOfWLApprox.def("Init", [](GeomInt_TheComputeLineBezierOfWLApprox &self) -> void { return self.Init(); });
	cls_GeomInt_TheComputeLineBezierOfWLApprox.def("Init", [](GeomInt_TheComputeLineBezierOfWLApprox &self, const Standard_Integer a0) -> void { return self.Init(a0); }, py::arg("degreemin"));
	cls_GeomInt_TheComputeLineBezierOfWLApprox.def("Init", [](GeomInt_TheComputeLineBezierOfWLApprox &self, const Standard_Integer a0, const Standard_Integer a1) -> void { return self.Init(a0, a1); }, py::arg("degreemin"), py::arg("degreemax"));
	cls_GeomInt_TheComputeLineBezierOfWLApprox.def("Init", [](GeomInt_TheComputeLineBezierOfWLApprox &self, const Standard_Integer a0, const Standard_Integer a1, const Standard_Real a2) -> void { return self.Init(a0, a1, a2); }, py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"));
	cls_GeomInt_TheComputeLineBezierOfWLApprox.def("Init", [](GeomInt_TheComputeLineBezierOfWLApprox &self, const Standard_Integer a0, const Standard_Integer a1, const Standard_Real a2, const Standard_Real a3) -> void { return self.Init(a0, a1, a2, a3); }, py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"));
	cls_GeomInt_TheComputeLineBezierOfWLApprox.def("Init", [](GeomInt_TheComputeLineBezierOfWLApprox &self, const Standard_Integer a0, const Standard_Integer a1, const Standard_Real a2, const Standard_Real a3, const Standard_Integer a4) -> void { return self.Init(a0, a1, a2, a3, a4); }, py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("NbIterations"));
	cls_GeomInt_TheComputeLineBezierOfWLApprox.def("Init", [](GeomInt_TheComputeLineBezierOfWLApprox &self, const Standard_Integer a0, const Standard_Integer a1, const Standard_Real a2, const Standard_Real a3, const Standard_Integer a4, const Standard_Boolean a5) -> void { return self.Init(a0, a1, a2, a3, a4, a5); }, py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("NbIterations"), py::arg("cutting"));
	cls_GeomInt_TheComputeLineBezierOfWLApprox.def("Init", [](GeomInt_TheComputeLineBezierOfWLApprox &self, const Standard_Integer a0, const Standard_Integer a1, const Standard_Real a2, const Standard_Real a3, const Standard_Integer a4, const Standard_Boolean a5, const Approx_ParametrizationType a6) -> void { return self.Init(a0, a1, a2, a3, a4, a5, a6); }, py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("NbIterations"), py::arg("cutting"), py::arg("parametrization"));
	cls_GeomInt_TheComputeLineBezierOfWLApprox.def("Init", (void (GeomInt_TheComputeLineBezierOfWLApprox::*)(const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real, const Standard_Integer, const Standard_Boolean, const Approx_ParametrizationType, const Standard_Boolean)) &GeomInt_TheComputeLineBezierOfWLApprox::Init, "Initializes the fields of the algorithm.", py::arg("degreemin"), py::arg("degreemax"), py::arg("Tolerance3d"), py::arg("Tolerance2d"), py::arg("NbIterations"), py::arg("cutting"), py::arg("parametrization"), py::arg("Squares"));
	cls_GeomInt_TheComputeLineBezierOfWLApprox.def("Perform", (void (GeomInt_TheComputeLineBezierOfWLApprox::*)(const GeomInt_TheMultiLineOfWLApprox &)) &GeomInt_TheComputeLineBezierOfWLApprox::Perform, "runs the algorithm after having initialized the fields.", py::arg("Line"));
	cls_GeomInt_TheComputeLineBezierOfWLApprox.def("SetDegrees", (void (GeomInt_TheComputeLineBezierOfWLApprox::*)(const Standard_Integer, const Standard_Integer)) &GeomInt_TheComputeLineBezierOfWLApprox::SetDegrees, "changes the degrees of the approximation.", py::arg("degreemin"), py::arg("degreemax"));
	cls_GeomInt_TheComputeLineBezierOfWLApprox.def("SetTolerances", (void (GeomInt_TheComputeLineBezierOfWLApprox::*)(const Standard_Real, const Standard_Real)) &GeomInt_TheComputeLineBezierOfWLApprox::SetTolerances, "Changes the tolerances of the approximation.", py::arg("Tolerance3d"), py::arg("Tolerance2d"));
	cls_GeomInt_TheComputeLineBezierOfWLApprox.def("SetConstraints", (void (GeomInt_TheComputeLineBezierOfWLApprox::*)(const AppParCurves_Constraint, const AppParCurves_Constraint)) &GeomInt_TheComputeLineBezierOfWLApprox::SetConstraints, "changes the first and the last constraint points.", py::arg("firstC"), py::arg("lastC"));
	cls_GeomInt_TheComputeLineBezierOfWLApprox.def("IsAllApproximated", (Standard_Boolean (GeomInt_TheComputeLineBezierOfWLApprox::*)() const ) &GeomInt_TheComputeLineBezierOfWLApprox::IsAllApproximated, "returns False if at a moment of the approximation, the status NoApproximation has been sent by the user when more points were needed.");
	cls_GeomInt_TheComputeLineBezierOfWLApprox.def("IsToleranceReached", (Standard_Boolean (GeomInt_TheComputeLineBezierOfWLApprox::*)() const ) &GeomInt_TheComputeLineBezierOfWLApprox::IsToleranceReached, "returns False if the status NoPointsAdded has been sent.");
	cls_GeomInt_TheComputeLineBezierOfWLApprox.def("Error", [](GeomInt_TheComputeLineBezierOfWLApprox &self, const Standard_Integer Index, Standard_Real & tol3d, Standard_Real & tol2d){ self.Error(Index, tol3d, tol2d); return std::tuple<Standard_Real &, Standard_Real &>(tol3d, tol2d); }, "returns the tolerances 2d and 3d of the <Index> MultiCurve.", py::arg("Index"), py::arg("tol3d"), py::arg("tol2d"));
	cls_GeomInt_TheComputeLineBezierOfWLApprox.def("NbMultiCurves", (Standard_Integer (GeomInt_TheComputeLineBezierOfWLApprox::*)() const ) &GeomInt_TheComputeLineBezierOfWLApprox::NbMultiCurves, "Returns the number of MultiCurve doing the approximation of the MultiLine.");
	cls_GeomInt_TheComputeLineBezierOfWLApprox.def("Value", [](GeomInt_TheComputeLineBezierOfWLApprox &self) -> const AppParCurves_MultiCurve & { return self.Value(); });
	cls_GeomInt_TheComputeLineBezierOfWLApprox.def("Value", (const AppParCurves_MultiCurve & (GeomInt_TheComputeLineBezierOfWLApprox::*)(const Standard_Integer) const ) &GeomInt_TheComputeLineBezierOfWLApprox::Value, "returns the result of the approximation.", py::arg("Index"));
	cls_GeomInt_TheComputeLineBezierOfWLApprox.def("ChangeValue", [](GeomInt_TheComputeLineBezierOfWLApprox &self) -> AppParCurves_MultiCurve & { return self.ChangeValue(); });
	cls_GeomInt_TheComputeLineBezierOfWLApprox.def("ChangeValue", (AppParCurves_MultiCurve & (GeomInt_TheComputeLineBezierOfWLApprox::*)(const Standard_Integer)) &GeomInt_TheComputeLineBezierOfWLApprox::ChangeValue, "returns the result of the approximation.", py::arg("Index"));
	cls_GeomInt_TheComputeLineBezierOfWLApprox.def("SplineValue", (const AppParCurves_MultiBSpCurve & (GeomInt_TheComputeLineBezierOfWLApprox::*)()) &GeomInt_TheComputeLineBezierOfWLApprox::SplineValue, "returns the result of the approximation.");
	cls_GeomInt_TheComputeLineBezierOfWLApprox.def("Parametrization", (Approx_ParametrizationType (GeomInt_TheComputeLineBezierOfWLApprox::*)() const ) &GeomInt_TheComputeLineBezierOfWLApprox::Parametrization, "returns the type of parametrization");
	cls_GeomInt_TheComputeLineBezierOfWLApprox.def("Parameters", [](GeomInt_TheComputeLineBezierOfWLApprox &self) -> const TColStd_Array1OfReal & { return self.Parameters(); });
	cls_GeomInt_TheComputeLineBezierOfWLApprox.def("Parameters", (const TColStd_Array1OfReal & (GeomInt_TheComputeLineBezierOfWLApprox::*)(const Standard_Integer) const ) &GeomInt_TheComputeLineBezierOfWLApprox::Parameters, "returns the new parameters of the approximation corresponding to the points of the multicurve <Index>.", py::arg("Index"));

	// C:\Miniconda\envs\occt\Library\include\opencascade\GeomInt.hxx
	py::class_<GeomInt, std::unique_ptr<GeomInt, Deleter<GeomInt>>> cls_GeomInt(mod, "GeomInt", "Provides intersections on between two surfaces of Geom. The result are curves from Geom.");
	cls_GeomInt.def(py::init<>());
	cls_GeomInt.def_static("AdjustPeriodic_", [](const Standard_Real thePar, const Standard_Real theParMin, const Standard_Real theParMax, const Standard_Real thePeriod, Standard_Real & theNewPar, Standard_Real & theOffset, const Standard_Real theEps){ Standard_Boolean rv = GeomInt::AdjustPeriodic(thePar, theParMin, theParMax, thePeriod, theNewPar, theOffset, theEps); return std::tuple<Standard_Boolean, Standard_Real &, Standard_Real &>(rv, theNewPar, theOffset); }, "Adjusts the parameter <thePar> to the range [theParMin, theParMax]", py::arg("thePar"), py::arg("theParMin"), py::arg("theParMax"), py::arg("thePeriod"), py::arg("theNewPar"), py::arg("theOffset"), py::arg("theEps"));

	/* FIXME
	// C:\Miniconda\envs\occt\Library\include\opencascade\GeomInt_WLApprox.hxx
	py::class_<(anonymous struct at C:\Miniconda\envs\occt\Library\include\opencascade\GeomInt_WLApprox.hxx:52:8), std::unique_ptr<(anonymous struct at C:\Miniconda\envs\occt\Library\include\opencascade\GeomInt_WLApprox.hxx:52:8), Deleter<(anonymous struct at C:\Miniconda\envs\occt\Library\include\opencascade\GeomInt_WLApprox.hxx:52:8)>>> cls_(mod, "", "None");
	cls_.def(py::init<>());
	*/

	// C:\Miniconda\envs\occt\Library\include\opencascade\GeomInt_VectorOfReal.hxx
	bind_NCollection_Vector<double>(mod, "GeomInt_VectorOfReal");

	// C:\Miniconda\envs\occt\Library\include\opencascade\GeomInt_SequenceOfParameterAndOrientation.hxx
	bind_NCollection_Sequence<GeomInt_ParameterAndOrientation>(mod, "GeomInt_SequenceOfParameterAndOrientation");


}
